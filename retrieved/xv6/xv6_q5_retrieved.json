[
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/syscall.c",
    "filename": "syscall.c",
    "relpath": "kernel/syscall.c",
    "start_line": 1,
    "end_line": 92,
    "length": 92,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "#include \"types.h\"\n#include \"param.h\"\n#include \"memlayout.h\"\n#include \"riscv.h\"\n#include \"spinlock.h\"\n#include \"proc.h\"\n#include \"syscall.h\"\n#include \"defs.h\"\n\n// Fetch the uint64 at addr from the current process.\nint\nfetchaddr(uint64 addr, uint64 *ip)\n{\n  struct proc *p = myproc();\n  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow\n    return -1;\n  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)\n    return -1;\n  return 0;\n}\n\n// Fetch the nul-terminated string at addr from the current process.\n// Returns length of string, not including nul, or -1 for error.\nint\nfetchstr(uint64 addr, char *buf, int max)\n{\n  struct proc *p = myproc();\n  if(copyinstr(p->pagetable, buf, addr, max) < 0)\n    return -1;\n  return strlen(buf);\n}\n\nstatic uint64\nargraw(int n)\n{\n  struct proc *p = myproc();\n  switch (n) {\n  case 0:\n    return p->trapframe->a0;\n  case 1:\n    return p->trapframe->a1;\n  case 2:\n    return p->trapframe->a2;\n  case 3:\n    return p->trapframe->a3;\n  case 4:\n    return p->trapframe->a4;\n  case 5:\n    return p->trapframe->a5;\n  }\n  panic(\"argraw\");\n  return -1;\n}\n\n// Fetch the nth 32-bit system call argument.\nvoid\nargint(int n, int *ip)\n{\n  *ip = argraw(n);\n}\n\n// Retrieve an argument as a pointer.\n// Doesn't check for legality, since\n// copyin/copyout will do that.\nvoid\nargaddr(int n, uint64 *ip)\n{\n  *ip = argraw(n);\n}\n\n// Fetch the nth word-sized system call argument as a null-terminated string.\n// Copies into buf, at most max.\n// Returns string length if OK (including nul), -1 if error.\nint\nargstr(int n, char *buf, int max)\n{\n  uint64 addr;\n  argaddr(n, &addr);\n  return fetchstr(addr, buf, max);\n}",
    "chunk_function_names": [
      "fetchaddr",
      "fetchstr",
      "argraw",
      "argint",
      "argaddr",
      "OK"
    ],
    "document_function_names": [
      "fetchaddr",
      "fetchstr",
      "argraw",
      "argint",
      "argaddr",
      "OK",
      "syscall"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/syscall.c",
    "filename": "syscall.c",
    "relpath": "kernel/syscall.c",
    "start_line": 92,
    "end_line": 147,
    "length": 56,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "static uint64 (*syscalls[])(void) = {\n[SYS_fork]    sys_fork,\n[SYS_exit]    sys_exit,\n[SYS_wait]    sys_wait,\n[SYS_pipe]    sys_pipe,\n[SYS_read]    sys_read,\n[SYS_kill]    sys_kill,\n[SYS_exec]    sys_exec,\n[SYS_fstat]   sys_fstat,\n[SYS_chdir]   sys_chdir,\n[SYS_dup]     sys_dup,\n[SYS_getpid]  sys_getpid,\n[SYS_sbrk]    sys_sbrk,\n[SYS_sleep]   sys_sleep,\n[SYS_uptime]  sys_uptime,\n[SYS_open]    sys_open,\n[SYS_write]   sys_write,\n[SYS_mknod]   sys_mknod,\n[SYS_unlink]  sys_unlink,\n[SYS_link]    sys_link,\n[SYS_mkdir]   sys_mkdir,\n[SYS_close]   sys_close,\n};\n\nvoid\nsyscall(void)\n{\n  int num;\n  struct proc *p = myproc();\n\n  num = p->trapframe->a7;\n  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {\n    // Use num to lookup the system call function for num, call it,\n    // and store its return value in p->trapframe->a0\n    p->trapframe->a0 = syscalls[num]();\n  } else {\n    printf(\"%d %s: unknown sys call %d\\n\",\n            p->pid, p->name, num);\n    p->trapframe->a0 = -1;\n  }\n}",
    "chunk_function_names": [
      "syscall"
    ],
    "document_function_names": [
      "fetchaddr",
      "fetchstr",
      "argraw",
      "argint",
      "argaddr",
      "OK",
      "syscall"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/sysfile.c",
    "filename": "sysfile.c",
    "relpath": "kernel/sysfile.c",
    "start_line": 407,
    "end_line": 505,
    "length": 99,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "uint64\nsys_chdir(void)\n{\n  char path[MAXPATH];\n  struct inode *ip;\n  struct proc *p = myproc();\n  \n  begin_op();\n  if(argstr(0, path, MAXPATH) < 0 || (ip = namei(path)) == 0){\n    end_op();\n    return -1;\n  }\n  ilock(ip);\n  if(ip->type != T_DIR){\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n  iunlock(ip);\n  iput(p->cwd);\n  end_op();\n  p->cwd = ip;\n  return 0;\n}\n\nuint64\nsys_exec(void)\n{\n  char path[MAXPATH], *argv[MAXARG];\n  int i;\n  uint64 uargv, uarg;\n\n  argaddr(1, &uargv);\n  if(argstr(0, path, MAXPATH) < 0) {\n    return -1;\n  }\n  memset(argv, 0, sizeof(argv));\n  for(i=0;; i++){\n    if(i >= NELEM(argv)){\n      goto bad;\n    }\n    if(fetchaddr(uargv+sizeof(uint64)*i, (uint64*)&uarg) < 0){\n      goto bad;\n    }\n    if(uarg == 0){\n      argv[i] = 0;\n      break;\n    }\n    argv[i] = kalloc();\n    if(argv[i] == 0)\n      goto bad;\n    if(fetchstr(uarg, argv[i], PGSIZE) < 0)\n      goto bad;\n  }\n\n  int ret = exec(path, argv);\n\n  for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)\n    kfree(argv[i]);\n\n  return ret;\n\n bad:\n  for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)\n    kfree(argv[i]);\n  return -1;\n}\n\nuint64\nsys_pipe(void)\n{\n  uint64 fdarray; // user pointer to array of two integers\n  struct file *rf, *wf;\n  int fd0, fd1;\n  struct proc *p = myproc();\n\n  argaddr(0, &fdarray);\n  if(pipealloc(&rf, &wf) < 0)\n    return -1;\n  fd0 = -1;\n  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){\n    if(fd0 >= 0)\n      p->ofile[fd0] = 0;\n    fileclose(rf);\n    fileclose(wf);\n    return -1;\n  }\n  if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||\n     copyout(p->pagetable, fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){\n    p->ofile[fd0] = 0;\n    p->ofile[fd1] = 0;\n    fileclose(rf);\n    fileclose(wf);\n    return -1;\n  }\n  return 0;\n}",
    "chunk_function_names": [
      "sys_chdir",
      "sys_exec",
      "sys_pipe"
    ],
    "document_function_names": [
      "argfd",
      "fdalloc",
      "sys_dup",
      "sys_read",
      "sys_write",
      "sys_close",
      "sys_fstat",
      "sys_link",
      "isdirempty",
      "sys_unlink",
      "sys_open",
      "sys_mkdir",
      "sys_mknod",
      "sys_chdir",
      "sys_exec",
      "sys_pipe"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/trap.c",
    "filename": "trap.c",
    "relpath": "kernel/trap.c",
    "start_line": 1,
    "end_line": 88,
    "length": 88,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "#include \"types.h\"\n#include \"param.h\"\n#include \"memlayout.h\"\n#include \"riscv.h\"\n#include \"spinlock.h\"\n#include \"proc.h\"\n#include \"defs.h\"\n\nstruct spinlock tickslock;\nuint ticks;\n\nextern char trampoline[], uservec[], userret[];\n\nvoid kernelvec();\n\nextern int devintr();\n\nvoid\ntrapinit(void)\n{\n  initlock(&tickslock, \"time\");\n}\n\nvoid\ntrapinithart(void)\n{\n  w_stvec((uint64)kernelvec);\n}\n\nvoid\nusertrap(void)\n{\n  int which_dev = 0;\n\n  if((r_sstatus() & SSTATUS_SPP) != 0)\n    panic(\"usertrap: not from user mode\");\n\n  w_stvec((uint64)kernelvec);\n\n  struct proc *p = myproc();\n  \n  p->trapframe->epc = r_sepc();\n  \n  if(r_scause() == 8){\n    if(killed(p))\n      exit(-1);\n\n    p->trapframe->epc += 4;\n\n    intr_on();\n\n    syscall();\n  } else if((which_dev = devintr()) != 0){\n    // ok\n  } else {\n    printf(\"usertrap(): unexpected scause 0x%lx pid=%d\\n\", r_scause(), p->pid);\n    printf(\"            sepc=0x%lx stval=0x%lx\\n\", r_sepc(), r_stval());\n    setkilled(p);\n  }\n\n  if(killed(p))\n    exit(-1);\n\n  if(which_dev == 2)\n    yield();\n\n  usertrapret();\n}",
    "chunk_function_names": [
      "trapinit",
      "trapinithart",
      "usertrap"
    ],
    "document_function_names": [
      "trapinit",
      "trapinithart",
      "usertrap",
      "usertrapret",
      "kerneltrap",
      "clockintr",
      "devintr"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/trap.c",
    "filename": "trap.c",
    "relpath": "kernel/trap.c",
    "start_line": 133,
    "end_line": 217,
    "length": 85,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "void \nkerneltrap()\n{\n  uint64 sepc = r_sepc();\n  uint64 sstatus = r_sstatus();\n  uint64 scause = r_scause();\n  \n  if((sstatus & SSTATUS_SPP) == 0)\n    panic(\"kerneltrap: not from supervisor mode\");\n\n  if((which_dev = devintr()) == 0){\n    // interrupt or trap from an unknown source\n    printf(\"scause=0x%lx sepc=0x%lx stval=0x%lx\\n\", scause, r_sepc(), r_stval());\n    panic(\"kerneltrap\");\n  }\n\n  // give up the CPU if this is a timer interrupt.\n  if(which_dev == 2 && myproc() != 0)\n    yield();\n\n  // the yield() may have caused some traps to occur,\n  // so restore trap registers for use by kernelvec.S's sepc instruction.\n  w_sepc(sepc);\n  w_sstatus(sstatus);\n}\n\nint\ndevintr()\n{\n  uint64 scause = r_scause();\n\n  if(scause == 0x8000000000000009L){\n    // this is a supervisor external interrupt, via PLIC.\n\n    // irq indicates which device interrupted.\n    int irq = plic_claim();\n\n    if(irq == UART0_IRQ){\n      uartintr();\n    } else if(irq == VIRTIO0_IRQ){\n      virtio_disk_intr();\n    } else if(irq){\n      printf(\"unexpected interrupt irq=%d\\n\", irq);\n    }\n\n    // the PLIC allows each device to raise at most one\n    // interrupt at a time; tell the PLIC the device is\n    // now allowed to interrupt again.\n    if(irq)\n      plic_complete(irq);\n\n    return 1;\n  } else if(scause == 0x8000000000000005L){\n    // timer interrupt.\n    clockintr();\n    return 2;\n  } else {\n    return 0;\n  }\n}",
    "chunk_function_names": [
      "kerneltrap",
      "clockintr",
      "devintr"
    ],
    "document_function_names": [
      "trapinit",
      "trapinithart",
      "usertrap",
      "usertrapret",
      "kerneltrap",
      "clockintr",
      "devintr"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/sysfile.c",
    "filename": "sysfile.c",
    "relpath": "kernel/sysfile.c",
    "start_line": 1,
    "end_line": 122,
    "length": 122,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "uint64\nsys_dup(void)\n{\n  struct file *f;\n  int fd;\n\n  if(argfd(0, 0, &f) < 0)\n    return -1;\n  if((fd=fdalloc(f)) < 0)\n    return -1;\n  filedup(f);\n  return fd;\n}\n\nuint64\nsys_read(void)\n{\n  struct file *f;\n  int n;\n  uint64 p;\n\n  argaddr(1, &p);\n  argint(2, &n);\n  if(argfd(0, 0, &f) < 0)\n    return -1;\n  return fileread(f, p, n);\n}\n\nuint64\nsys_write(void)\n{\n  struct file *f;\n  int n;\n  uint64 p;\n  \n  argaddr(1, &p);\n  argint(2, &n);\n  if(argfd(0, 0, &f) < 0)\n    return -1;\n\n  return filewrite(f, p, n);\n}\n\nuint64\nsys_close(void)\n{\n  int fd;\n  struct file *f;\n\n  if(argfd(0, &fd, &f) < 0)\n    return -1;\n  myproc()->ofile[fd] = 0;\n  fileclose(f);\n  return 0;\n}\n\nuint64\nsys_fstat(void)\n{\n  struct file *f;\n  uint64 st; // user pointer to struct stat\n\n  argaddr(1, &st);\n  if(argfd(0, 0, &f) < 0)\n    return -1;\n  return filestat(f, st);\n}",
    "chunk_function_names": [
      "argfd",
      "fdalloc",
      "sys_dup",
      "sys_read",
      "sys_write",
      "sys_close",
      "sys_fstat"
    ],
    "document_function_names": [
      "argfd",
      "fdalloc",
      "sys_dup",
      "sys_read",
      "sys_write",
      "sys_close",
      "sys_fstat",
      "sys_link",
      "isdirempty",
      "sys_unlink",
      "sys_open",
      "sys_mkdir",
      "sys_mknod",
      "sys_chdir",
      "sys_exec",
      "sys_pipe"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/syscall.h",
    "filename": "syscall.h",
    "relpath": "kernel/syscall.h",
    "start_line": 1,
    "end_line": 22,
    "length": 22,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// System call numbers\n#define SYS_fork    1\n#define SYS_exit    2\n#define SYS_wait    3\n#define SYS_pipe    4\n#define SYS_read    5\n#define SYS_kill    6\n#define SYS_exec    7\n#define SYS_fstat   8\n#define SYS_chdir   9\n#define SYS_dup    10\n#define SYS_getpid 11\n#define SYS_sbrk   12\n#define SYS_sleep  13\n#define SYS_uptime 14\n#define SYS_open   15\n#define SYS_write  16\n#define SYS_mknod  17\n#define SYS_unlink 18\n#define SYS_link   19\n#define SYS_mkdir  20\n#define SYS_close  21"
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/user/user.h",
    "filename": "user.h",
    "relpath": "user/user.h",
    "start_line": 1,
    "end_line": 43,
    "length": 43,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "int fork(void);\nint exit(int) __attribute__((noreturn));\nint wait(int*);\nint pipe(int*);\nint write(int, const void*, int);\nint read(int, void*, int);\nint close(int);\nint kill(int);\nint exec(const char*, char**);\nint open(const char*, int);\nint mknod(const char*, short, short);\nint unlink(const char*);\nint fstat(int fd, struct stat*);\nint link(const char*, const char*);\nint mkdir(const char*);\nint chdir(const char*);\nint dup(int);\nint getpid(void);\nchar* sbrk(int);\nint sleep(int);\nint uptime(void);"
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/sysproc.c",
    "filename": "sysproc.c",
    "relpath": "kernel/sysproc.c",
    "start_line": 1,
    "end_line": 93,
    "length": 93,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "uint64\nsys_exit(void)\n{\n  int n;\n  argint(0, &n);\n  exit(n);\n  return 0;  // not reached\n}\n\nuint64\nsys_getpid(void)\n{\n  return myproc()->pid;\n}\n\nuint64\nsys_fork(void)\n{\n  return fork();\n}\n\nuint64\nsys_wait(void)\n{\n  uint64 p;\n  argaddr(0, &p);\n  return wait(p);\n}\n\nuint64\nsys_sbrk(void)\n{\n  uint64 addr;\n  int n;\n\n  argint(0, &n);\n  addr = myproc()->sz;\n  if(growproc(n) < 0)\n    return -1;\n  return addr;\n}\n\nuint64\nsys_sleep(void)\n{\n  int n;\n  uint ticks0;\n\n  argint(0, &n);\n  if(n < 0)\n    n = 0;\n  acquire(&tickslock);\n  ticks0 = ticks;\n  while(ticks - ticks0 < n){\n    if(killed(myproc())){\n      release(&tickslock);\n      return -1;\n    }\n    sleep(&ticks, &tickslock);\n  }\n  release(&tickslock);\n  return 0;\n}\n\nuint64\nsys_kill(void)\n{\n  int pid;\n\n  argint(0, &pid);\n  return kill(pid);\n}\n\n// return how many clock tick interrupts have occurred\n// since start.\nuint64\nsys_uptime(void)\n{\n  uint xticks;\n\n  acquire(&tickslock);\n  xticks = ticks;\n  release(&tickslock);\n  return xticks;\n}",
    "chunk_function_names": [
      "sys_exit",
      "sys_getpid",
      "sys_fork",
      "sys_wait",
      "sys_sbrk",
      "sys_sleep",
      "sys_kill",
      "sys_uptime"
    ],
    "document_function_names": [
      "sys_exit",
      "sys_getpid",
      "sys_fork",
      "sys_wait",
      "sys_sbrk",
      "sys_sleep",
      "sys_kill",
      "sys_uptime"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 522,
    "end_line": 624,
    "length": 103,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Kill the process with the given pid.\n// The victim won't exit until it tries to return\n// to user space (see usertrap() in trap.c).\nint\nkill(int pid)\n{\n  struct proc *p;\n\n  for(p = proc; p < &proc[NPROC]; p++){\n    acquire(&p->lock);\n    if(p->pid == pid){\n      p->killed = 1;\n      if(p->state == SLEEPING){\n        // Wake process from sleep().\n        p->state = RUNNABLE;\n      }\n      release(&p->lock);\n      return 0;\n    }\n    release(&p->lock);\n  }\n  return -1;\n}",
    "chunk_function_names": [
      "forkret",
      "sleep",
      "wakeup",
      "space",
      "setkilled"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  }
]