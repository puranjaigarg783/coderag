[
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/riscv.h",
    "filename": "riscv.h",
    "relpath": "kernel/riscv.h",
    "start_line": 216,
    "end_line": 341,
    "length": 126,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// supervisor address translation and protection;\n// holds the address of the page table.\nstatic inline void \nw_satp(uint64 x)\n{\n  asm volatile(\"csrw satp, %0\" : : \"r\" (x));\n}\n\nstatic inline uint64\nr_satp()\n{\n  uint64 x;\n  asm volatile(\"csrr %0, satp\" : \"=r\" (x) );\n  return x;\n}",
    "chunk_function_names": [
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra"
    ],
    "document_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie",
      "MIE_STIE",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0",
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra",
      "sfence_vma"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/riscv.h",
    "filename": "riscv.h",
    "relpath": "kernel/riscv.h",
    "start_line": 1,
    "end_line": 382,
    "length": 382,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// __ASSEMBLER__\n\n#define PGSIZE 4096 // bytes per page\n#define PGSHIFT 12  // bits of offset within a page\n\n#define PTE_V (1L << 0) // valid\n#define PTE_R (1L << 1)\n#define PTE_W (1L << 2)\n#define PTE_X (1L << 3)\n#define PTE_U (1L << 4) // user can access\n\n// shift a physical address to the right place for a PTE.\n#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)\n\n#define PTE2PA(pte) (((pte) >> 10) << 12)\n\n#define PTE_FLAGS(pte) ((pte) & 0x3FF)",
    "document_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie",
      "MIE_STIE",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0",
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra",
      "sfence_vma"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/riscv.h",
    "filename": "riscv.h",
    "relpath": "kernel/riscv.h",
    "start_line": 341,
    "end_line": 352,
    "length": 12,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "static inline void\nsfence_vma()\n{\n  // the zero, zero means flush all TLB entries.\n  asm volatile(\"sfence.vma zero, zero\");\n}",
    "chunk_function_names": [
      "sfence_vma"
    ],
    "document_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie",
      "MIE_STIE",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0",
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra",
      "sfence_vma"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/vm.c",
    "filename": "vm.c",
    "relpath": "kernel/vm.c",
    "start_line": 1,
    "end_line": 81,
    "length": 81,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Make a direct-map page table for the kernel.\npagetable_t\nkvmmake(void)\n{\n  pagetable_t kpgtbl;\n\n  kpgtbl = (pagetable_t) kalloc();\n  memset(kpgtbl, 0, PGSIZE);\n\n  // uart registers\n  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);\n\n  // virtio mmio disk interface\n  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);\n\n  // PLIC\n  kvmmap(kpgtbl, PLIC, PLIC, 0x4000000, PTE_R | PTE_W);\n\n  // map kernel text executable and read-only.\n  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);\n\n  // map kernel data and the physical RAM we'll make use of.\n  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);\n\n  // map the trampoline for trap entry/exit to\n  // the highest virtual address in the kernel.\n  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);\n\n  return kpgtbl;\n}",
    "chunk_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart"
    ],
    "document_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart",
      "walkaddr",
      "kvmmap",
      "walk",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst",
      "uvmalloc",
      "uvmdealloc",
      "freewalk",
      "uvmfree",
      "uvmcopy",
      "uvmclear",
      "copyout",
      "copyin",
      "copyinstr"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/riscv.h",
    "filename": "riscv.h",
    "relpath": "kernel/riscv.h",
    "start_line": 100,
    "end_line": 216,
    "length": 117,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Machine Exception Delegation\nstatic inline uint64\nr_medeleg()\n{\n  uint64 x;\n  asm volatile(\"csrr %0, medeleg\" : \"=r\" (x) );\n  return x;\n}\n\nstatic inline void \nw_medeleg(uint64 x)\n{\n  asm volatile(\"csrw medeleg, %0\" : : \"r\" (x));\n}\n\n// Machine Interrupt Delegation\nstatic inline uint64\nr_mideleg()\n{\n  uint64 x;\n  asm volatile(\"csrr %0, mideleg\" : \"=r\" (x) );\n  return x;\n}\n\nstatic inline void \nw_mideleg(uint64 x)\n{\n  asm volatile(\"csrw mideleg, %0\" : : \"r\" (x));\n}",
    "chunk_function_names": [
      "r_mie",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0"
    ],
    "document_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie",
      "MIE_STIE",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0",
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra",
      "sfence_vma"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/trap.c",
    "filename": "trap.c",
    "relpath": "kernel/trap.c",
    "start_line": 133,
    "end_line": 217,
    "length": 85,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// check if it's an external interrupt or software interrupt,\n// and handle it.\n// returns 2 if timer interrupt,\n// 1 if other device,\n// 0 if not recognized.\nint\ndevintr()\n{\n  uint64 scause = r_scause();\n\n  if(scause == 0x8000000000000009L){\n    // this is a supervisor external interrupt, via PLIC.\n\n    // irq indicates which device interrupted.\n    int irq = plic_claim();\n\n    if(irq == UART0_IRQ){\n      uartintr();\n    } else if(irq == VIRTIO0_IRQ){\n      virtio_disk_intr();\n    } else if(irq){\n      printf(\"unexpected interrupt irq=%d\\n\", irq);\n    }\n\n    // the PLIC allows each device to raise at most one\n    // interrupt at a time; tell the PLIC the device is\n    // now allowed to interrupt again.\n    if(irq)\n      plic_complete(irq);\n\n    return 1;\n  } else if(scause == 0x8000000000000005L){\n    // timer interrupt.\n    clockintr();\n    return 2;\n  } else {\n    return 0;\n  }\n}",
    "chunk_function_names": [
      "kerneltrap",
      "clockintr",
      "devintr"
    ],
    "document_function_names": [
      "trapinit",
      "trapinithart",
      "usertrap",
      "usertrapret",
      "kerneltrap",
      "clockintr",
      "devintr"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/main.c",
    "filename": "main.c",
    "relpath": "kernel/main.c",
    "start_line": 1,
    "end_line": 45,
    "length": 45,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// start() jumps here in supervisor mode on all CPUs.\nvoid\nmain()\n{\n  if(cpuid() == 0){\n    kinit();         // physical page allocator\n    kvminit();       // create kernel page table\n    kvminithart();   // turn on paging\n    procinit();      // process table\n    trapinit();      // trap vectors\n    trapinithart();  // install kernel trap vector\n    plicinit();      // set up interrupt controller\n    plicinithart();  // ask PLIC for device interrupts\n    binit();         // buffer cache\n    iinit();         // inode table\n    fileinit();      // file table\n    virtio_disk_init(); // emulated hard disk\n    userinit();      // first user process\n    __sync_synchronize();\n    started = 1;\n  } else {\n    while(started == 0)\n      ;\n    __sync_synchronize();\n    kvminithart();    // turn on paging\n    trapinithart();   // install kernel trap vector\n    plicinithart();   // ask PLIC for device interrupts\n  }\n\n  scheduler();        \n}",
    "chunk_function_names": [
      "main"
    ],
    "document_function_names": [
      "main"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/memlayout.h",
    "filename": "memlayout.h",
    "relpath": "kernel/memlayout.h",
    "start_line": 1,
    "end_line": 59,
    "length": 59,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// qemu puts platform-level interrupt controller (PLIC) here.\n#define PLIC 0x0c000000L\n#define PLIC_PRIORITY (PLIC + 0x0)\n#define PLIC_PENDING (PLIC + 0x1000)\n#define PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)\n#define PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)\n#define PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)"
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/spinlock.c",
    "filename": "spinlock.c",
    "relpath": "kernel/spinlock.c",
    "start_line": 1,
    "end_line": 75,
    "length": 75,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Mutual exclusion spin locks.\n\n#include \"types.h\"\n#include \"param.h\"\n#include \"memlayout.h\"\n#include \"spinlock.h\"\n#include \"riscv.h\"\n#include \"proc.h\"\n#include \"defs.h\"\n\nvoid\ninitlock(struct spinlock *lk, char *name)\n{\n  lk->name = name;\n  lk->locked = 0;\n  lk->cpu = 0;\n}\n\n// Acquire the lock.\n// Loops (spins) until the lock is acquired.\nvoid\nacquire(struct spinlock *lk)\n{\n  push_off(); // disable interrupts to avoid deadlock.\n  if(holding(lk))\n    panic(\"acquire\");\n\n  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:\n  //   a5 = 1\n  //   s1 = &lk->locked\n  //   amoswap.w.aq a5, a5, (s1)\n  while(__sync_lock_test_and_set(&lk->locked, 1) != 0)\n    ;\n\n  // Tell the C compiler and the processor to not move loads or stores\n  // past this point, to ensure that the critical section's memory\n  // references happen strictly after the lock is acquired.\n  // On RISC-V, this emits a fence instruction.\n  __sync_synchronize();\n\n  // Record info about lock acquisition for holding() and debugging.\n  lk->cpu = mycpu();\n}\n\n// Release the lock.\nvoid\nrelease(struct spinlock *lk)\n{\n  if(!holding(lk))\n    panic(\"release\");\n\n  lk->cpu = 0;\n\n  // Tell the C compiler and the CPU to not move loads or stores\n  // past this point, to ensure that all the stores in the critical\n  // section are visible to other CPUs before the lock is released,\n  // and that loads in the critical section occur strictly before\n  // the lock is released.\n  // On RISC-V, this emits a fence instruction.\n  __sync_synchronize();\n\n  // Release the lock, equivalent to lk->locked = 0.\n  // This code doesn't use a C assignment, since the C standard\n  // implies that an assignment might be implemented with\n  // multiple store instructions.\n  // On RISC-V, sync_lock_release turns into an atomic swap:\n  //   s1 = &lk->locked\n  //   amoswap.w zero, zero, (s1)\n  __sync_lock_release(&lk->locked);\n\n  pop_off();\n}",
    "chunk_function_names": [
      "initlock",
      "acquire",
      "release"
    ],
    "document_function_names": [
      "initlock",
      "acquire",
      "release",
      "holding",
      "intr_off",
      "pop_off"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/vm.c",
    "filename": "vm.c",
    "relpath": "kernel/vm.c",
    "start_line": 81,
    "end_line": 142,
    "length": 62,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "pte_t *\nwalk(pagetable_t pagetable, uint64 va, int alloc)\n{\n  if(va >= MAXVA)\n    panic(\"walk\");\n\n  for(int level = 2; level > 0; level--) {\n    pte_t *pte = &pagetable[PX(level, va)];\n    if(*pte & PTE_V) {\n      pagetable = (pagetable_t)PTE2PA(*pte);\n    } else {\n      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)\n        return 0;\n      memset(pagetable, 0, PGSIZE);\n      *pte = PA2PTE(pagetable) | PTE_V;\n    }\n  }\n  return &pagetable[PX(0, va)];\n}\n\nuint64\nwalkaddr(pagetable_t pagetable, uint64 va)\n{\n  pte_t *pte;\n  uint64 pa;\n\n  if(va >= MAXVA)\n    return 0;\n\n  pte = walk(pagetable, va, 0);\n  if(pte == 0)\n    return 0;\n  if((*pte & PTE_V) == 0)\n    return 0;\n  if((*pte & PTE_U) == 0)\n    return 0;\n  pa = PTE2PA(*pte);\n  return pa;\n}",
    "chunk_function_names": [
      "walkaddr",
      "kvmmap"
    ],
    "document_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart",
      "walkaddr",
      "kvmmap",
      "walk",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst",
      "uvmalloc",
      "uvmdealloc",
      "freewalk",
      "uvmfree",
      "uvmcopy",
      "uvmclear",
      "copyout",
      "copyin",
      "copyinstr"
    ]
  }
]