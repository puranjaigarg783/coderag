[
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 255,
    "end_line": 345,
    "length": 91,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Create a new process, copying the parent.\n// Sets up child kernel stack to return as if from fork() system call.\nint\nfork(void)\n{\n  int i, pid;\n  struct proc *np;\n  struct proc *p = myproc();\n\n  // Allocate process.\n  if((np = allocproc()) == 0){\n    return -1;\n  }\n\n  // Copy user memory from parent to child.\n  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){\n    freeproc(np);\n    release(&np->lock);\n    return -1;\n  }\n  np->sz = p->sz;\n\n  // copy saved user registers.\n  *(np->trapframe) = *(p->trapframe);\n\n  // Cause fork to return 0 in the child.\n  np->trapframe->a0 = 0;\n\n  // increment reference counts on open file descriptors.\n  for(i = 0; i < NOFILE; i++)\n    if(p->ofile[i])\n      np->ofile[i] = filedup(p->ofile[i]);\n  np->cwd = idup(p->cwd);\n\n  safestrcpy(np->name, p->name, sizeof(p->name));\n\n  pid = np->pid;\n\n  release(&np->lock);\n\n  acquire(&wait_lock);\n  np->parent = p;\n  release(&wait_lock);\n\n  acquire(&np->lock);\n  np->state = RUNNABLE;\n  release(&np->lock);\n\n  return pid;\n}",
    "chunk_function_names": [
      "growproc",
      "fork",
      "reparent"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 1,
    "end_line": 107,
    "length": 107,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Allocate a page for each process's kernel stack.\n// Map it high in memory, followed by an invalid\n// guard page.\nvoid\nproc_mapstacks(pagetable_t kpgtbl)\n{\n  struct proc *p;\n  \n  for(p = proc; p < &proc[NPROC]; p++) {\n    char *pa = kalloc();\n    if(pa == 0)\n      panic(\"kalloc\");\n    uint64 va = KSTACK((int) (p - proc));\n    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);\n  }\n}\n\n// initialize the proc table.\nvoid\nprocinit(void)\n{\n  struct proc *p;\n  \n  initlock(&pid_lock, \"nextpid\");\n  initlock(&wait_lock, \"wait_lock\");\n  for(p = proc; p < &proc[NPROC]; p++) {\n      initlock(&p->lock, \"proc\");\n      p->state = UNUSED;\n      p->kstack = KSTACK((int) (p - proc));\n  }\n}\n\n// Must be called with interrupts disabled,\n// to prevent race with process being moved\n// to a different CPU.\nint\ncpuid()\n{\n  int id = r_tp();\n  return id;\n}\n\n// Return this CPU's cpu struct.\n// Interrupts must be disabled.\nstruct cpu*\nmycpu(void)\n{\n  int id = cpuid();\n  struct cpu *c = &cpus[id];\n  return c;\n}\n\n// Return the current struct proc *, or zero if none.\nstruct proc*\nmyproc(void)\n{\n  push_off();\n  struct cpu *c = mycpu();\n  struct proc *p = c->proc;\n  pop_off();\n  return p;\n}\n\nint\nallocpid()\n{\n  int pid;\n  \n  acquire(&pid_lock);\n  pid = nextpid;\n  nextpid = nextpid + 1;\n  release(&pid_lock);\n\n  return pid;\n}",
    "chunk_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 522,
    "end_line": 624,
    "length": 103,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "void\nforkret(void)\n{\n  static int first = 1;\n\n  // Still holding p->lock from scheduler.\n  release(&myproc()->lock);\n\n  if (first) {\n    // File system initialization must be run in the context of a\n    // regular process (e.g., because it calls sleep), and thus cannot\n    // be run from main().\n    fsinit(ROOTDEV);\n\n    first = 0;\n    // ensure other cores see first=0.\n    __sync_synchronize();\n  }\n\n  usertrapret();\n}",
    "chunk_function_names": [
      "forkret",
      "sleep",
      "wakeup",
      "space",
      "setkilled"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 107,
    "end_line": 175,
    "length": 69,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// If there are no free procs, or a memory allocation fails, return 0.\nstatic struct proc*\nallocproc(void)\n{\n  struct proc *p;\n\n  for(p = proc; p < &proc[NPROC]; p++) {\n    acquire(&p->lock);\n    if(p->state == UNUSED) {\n      goto found;\n    } else {\n      release(&p->lock);\n    }\n  }\n  return 0;\n\nfound:\n  p->pid = allocpid();\n  p->state = USED;\n\n  // Allocate a trapframe page.\n  if((p->trapframe = (struct trapframe *)kalloc()) == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n\n  // An empty user page table.\n  p->pagetable = proc_pagetable(p);\n  if(p->pagetable == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n\n  // Set up new context to start executing at forkret,\n  // which returns to user space.\n  memset(&p->context, 0, sizeof(p->context));\n  p->context.ra = (uint64)forkret;\n  p->context.sp = p->kstack + PGSIZE;\n\n  return p;\n}\n\n// free a proc structure and the data hanging from it,\n// including user pages.\n// p->lock must be held.\nstatic void\nfreeproc(struct proc *p)\n{\n  if(p->trapframe)\n    kfree((void*)p->trapframe);\n  p->trapframe = 0;\n  if(p->pagetable)\n    proc_freepagetable(p->pagetable, p->sz);\n  p->pagetable = 0;\n  p->sz = 0;\n  p->pid = 0;\n  p->parent = 0;\n  p->name[0] = 0;\n  p->chan = 0;\n  p->killed = 0;\n  p->xstate = 0;\n  p->state = UNUSED;\n}",
    "chunk_function_names": [
      "freeproc"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 345,
    "end_line": 440,
    "length": 96,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "void\nexit(int status)\n{\n  struct proc *p = myproc();\n\n  if(p == initproc)\n    panic(\"init exiting\");\n\n  // Close all open files.\n  for(int fd = 0; fd < NOFILE; fd++){\n    if(p->ofile[fd]){\n      struct file *f = p->ofile[fd];\n      fileclose(f);\n      p->ofile[fd] = 0;\n    }\n  }\n\n  begin_op();\n  iput(p->cwd);\n  end_op();\n  p->cwd = 0;\n\n  acquire(&wait_lock);\n\n  // Give any children to init.\n  reparent(p);\n\n  // Parent might be sleeping in wait().\n  wakeup(p->parent);\n  \n  acquire(&p->lock);\n\n  p->xstate = status;\n  p->state = ZOMBIE;\n\n  release(&wait_lock);\n\n  // Jump into the scheduler, never to return.\n  sched();\n  panic(\"zombie exit\");\n}\n\n// Per-CPU process scheduler.\n// Each CPU calls scheduler() after setting itself up.\n// Scheduler never returns.  It loops, doing:\n//  - choose a process to run.",
    "chunk_function_names": [
      "exit",
      "wait"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 175,
    "end_line": 255,
    "length": 81,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "pagetable_t\nproc_pagetable(struct proc *p)\n{\n  pagetable_t pagetable;\n\n  // An empty page table.\n  pagetable = uvmcreate();\n  if(pagetable == 0)\n    return 0;\n\n  // map the trampoline code (for system call return)\n  // at the highest user virtual address.\n  // only the supervisor uses it, on the way\n  // to/from user space, so not PTE_U.\n  if(mappages(pagetable, TRAMPOLINE, PGSIZE,\n              (uint64)trampoline, PTE_R | PTE_X) < 0){\n    uvmfree(pagetable, 0);\n    return 0;\n  }\n\n  // map the trapframe page just below the trampoline page, for\n  // trampoline.S.\n  if(mappages(pagetable, TRAPFRAME, PGSIZE,\n              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){\n    uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n    uvmfree(pagetable, 0);\n    return 0;\n  }\n\n  return pagetable;\n}\n\nvoid\nproc_freepagetable(pagetable_t pagetable, uint64 sz)\n{\n  uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n  uvmunmap(pagetable, TRAPFRAME, 1, 0);\n  uvmfree(pagetable, sz);\n}",
    "chunk_function_names": [
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 440,
    "end_line": 522,
    "length": 83,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "void\nscheduler(void)\n{\n  struct proc *p;\n  struct cpu *c = mycpu();\n\n  c->proc = 0;\n  for(;;){\n    intr_on();\n\n    int found = 0;\n    for(p = proc; p < &proc[NPROC]; p++) {\n      acquire(&p->lock);\n      if(p->state == RUNNABLE) {\n        p->state = RUNNING;\n        c->proc = p;\n        swtch(&c->context, &p->context);\n        c->proc = 0;\n        found = 1;\n      }\n      release(&p->lock);\n    }\n    if(found == 0) {\n      intr_on();\n      asm volatile(\"wfi\");\n    }\n  }\n}\n\nvoid\nsched(void)\n{\n  int intena;\n  struct proc *p = myproc();\n\n  if(!holding(&p->lock))\n    panic(\"sched p->lock\");\n  if(mycpu()->noff != 1)\n    panic(\"sched locks\");\n  if(p->state == RUNNING)\n    panic(\"sched running\");\n  if(intr_get())\n    panic(\"sched interruptible\");\n\n  intena = mycpu()->intena;\n  swtch(&p->context, &mycpu()->context);\n  mycpu()->intena = intena;\n}\n\nvoid\nyield(void)\n{\n  struct proc *p = myproc();\n  acquire(&p->lock);\n  p->state = RUNNABLE;\n  sched();\n  release(&p->lock);\n}",
    "chunk_function_names": [
      "scheduler",
      "sched",
      "yield"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 624,
    "end_line": 695,
    "length": 72,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "int\nkilled(struct proc *p)\n{\n  int k;\n  \n  acquire(&p->lock);\n  k = p->killed;\n  release(&p->lock);\n  return k;\n}\n\n// Copy to either a user address, or kernel address,\n// depending on usr_dst.\n// Returns 0 on success, -1 on error.\nint\neither_copyout(int user_dst, uint64 dst, void *src, uint64 len)\n{\n  struct proc *p = myproc();\n  if(user_dst){\n    return copyout(p->pagetable, dst, src, len);\n  } else {\n    memmove((char *)dst, src, len);\n    return 0;\n  }\n}\n\n// Copy from either a user address, or kernel address,\n// depending on usr_src.\n// Returns 0 on success, -1 on error.\nint\neither_copyin(void *dst, int user_src, uint64 src, uint64 len)\n{\n  struct proc *p = myproc();\n  if(user_src){\n    return copyin(p->pagetable, dst, src, len);\n  } else {\n    memmove(dst, (char*)src, len);\n    return 0;\n  }\n}",
    "chunk_function_names": [
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  }
]