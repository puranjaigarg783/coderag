[
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/vm.c",
    "filename": "vm.c",
    "relpath": "kernel/vm.c",
    "start_line": 81,
    "end_line": 142,
    "length": 62,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "pte_t *\nwalk(pagetable_t pagetable, uint64 va, int alloc)\n{\n  if(va >= MAXVA)\n    panic(\"walk\");\n\n  for(int level = 2; level > 0; level--) {\n    pte_t *pte = &pagetable[PX(level, va)];\n    if(*pte & PTE_V) {\n      pagetable = (pagetable_t)PTE2PA(*pte);\n    } else {\n      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)\n        return 0;\n      memset(pagetable, 0, PGSIZE);\n      *pte = PA2PTE(pagetable) | PTE_V;\n    }\n  }\n  return &pagetable[PX(0, va)];\n}\n\nuint64\nwalkaddr(pagetable_t pagetable, uint64 va)\n{\n  pte_t *pte;\n  uint64 pa;\n\n  if(va >= MAXVA)\n    return 0;\n\n  pte = walk(pagetable, va, 0);\n  if(pte == 0)\n    return 0;\n  if((*pte & PTE_V) == 0)\n    return 0;\n  if((*pte & PTE_U) == 0)\n    return 0;\n  pa = PTE2PA(*pte);\n  return pa;\n}",
    "chunk_function_names": [
      "walkaddr",
      "kvmmap"
    ],
    "document_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart",
      "walkaddr",
      "kvmmap",
      "walk",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst",
      "uvmalloc",
      "uvmdealloc",
      "freewalk",
      "uvmfree",
      "uvmcopy",
      "uvmclear",
      "copyout",
      "copyin",
      "copyinstr"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/riscv.h",
    "filename": "riscv.h",
    "relpath": "kernel/riscv.h",
    "start_line": 216,
    "end_line": 341,
    "length": 126,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// use riscv's sv39 page table scheme.\n#define SATP_SV39 (8L << 60)\n\n#define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) >> 12))\n\n// supervisor address translation and protection;\n// holds the address of the page table.\nstatic inline void \nw_satp(uint64 x)\n{\n  asm volatile(\"csrw satp, %0\" : : \"r\" (x));\n}",
    "chunk_function_names": [
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra"
    ],
    "document_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie",
      "MIE_STIE",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0",
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra",
      "sfence_vma"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/syscall.c",
    "filename": "syscall.c",
    "relpath": "kernel/syscall.c",
    "start_line": 1,
    "end_line": 92,
    "length": 92,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Fetch the uint64 at addr from the current process.\nint\nfetchaddr(uint64 addr, uint64 *ip)\n{\n  struct proc *p = myproc();\n  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow\n    return -1;\n  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)\n    return -1;\n  return 0;\n}\n\n// Fetch the nul-terminated string at addr from the current process.\n// Returns length of string, not including nul, or -1 for error.\nint\nfetchstr(uint64 addr, char *buf, int max)\n{\n  struct proc *p = myproc();\n  if(copyinstr(p->pagetable, buf, addr, max) < 0)\n    return -1;\n  return strlen(buf);\n}\n\nstatic uint64\nargraw(int n)\n{\n  struct proc *p = myproc();\n  switch (n) {\n  case 0:\n    return p->trapframe->a0;\n  case 1:\n    return p->trapframe->a1;\n  case 2:\n    return p->trapframe->a2;\n  case 3:\n    return p->trapframe->a3;\n  case 4:\n    return p->trapframe->a4;\n  case 5:\n    return p->trapframe->a5;\n  }\n  panic(\"argraw\");\n  return -1;\n}\n\n// Fetch the nth 32-bit system call argument.\nvoid\nargint(int n, int *ip)\n{\n  *ip = argraw(n);\n}\n\n// Retrieve an argument as a pointer.\n// Doesn't check for legality, since\n// copyin/copyout will do that.\nvoid\nargaddr(int n, uint64 *ip)\n{\n  *ip = argraw(n);\n}\n\n// Fetch the nth word-sized system call argument as a null-terminated string.\n// Copies into buf, at most max.\n// Returns string length if OK (including nul), -1 if error.\nint\nargstr(int n, char *buf, int max)\n{\n  uint64 addr;\n  argaddr(n, &addr);\n  return fetchstr(addr, buf, max);\n}",
    "chunk_function_names": [
      "fetchaddr",
      "fetchstr",
      "argraw",
      "argint",
      "argaddr",
      "OK"
    ],
    "document_function_names": [
      "fetchaddr",
      "fetchstr",
      "argraw",
      "argint",
      "argaddr",
      "OK",
      "syscall"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/vm.c",
    "filename": "vm.c",
    "relpath": "kernel/vm.c",
    "start_line": 231,
    "end_line": 311,
    "length": 81,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "uint64\nuvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)\n{\n  char *mem;\n  uint64 a;\n\n  if(newsz < oldsz)\n    return oldsz;\n\n  oldsz = PGROUNDUP(oldsz);\n  for(a = oldsz; a < newsz; a += PGSIZE){\n    mem = kalloc();\n    if(mem == 0){\n      uvmdealloc(pagetable, a, oldsz);\n      return 0;\n    }\n    memset(mem, 0, PGSIZE);\n    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){\n      kfree(mem);\n      uvmdealloc(pagetable, a, oldsz);\n      return 0;\n    }\n  }\n  return newsz;\n}\n\nuint64\nuvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)\n{\n  if(newsz >= oldsz)\n    return oldsz;\n\n  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){\n    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;\n    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);\n  }\n\n  return newsz;\n}\n\nvoid\nfreewalk(pagetable_t pagetable)\n{\n  for(int i = 0; i < 512; i++){\n    pte_t pte = pagetable[i];\n    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){\n      uint64 child = PTE2PA(pte);\n      freewalk((pagetable_t)child);\n      pagetable[i] = 0;\n    } else if(pte & PTE_V){\n      panic(\"freewalk: leaf\");\n    }\n  }\n  kfree((void*)pagetable);\n}\n\nvoid\nuvmfree(pagetable_t pagetable, uint64 sz)\n{\n  if(sz > 0)\n    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);\n  freewalk(pagetable);\n}",
    "chunk_function_names": [
      "uvmalloc",
      "uvmdealloc",
      "freewalk",
      "uvmfree"
    ],
    "document_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart",
      "walkaddr",
      "kvmmap",
      "walk",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst",
      "uvmalloc",
      "uvmdealloc",
      "freewalk",
      "uvmfree",
      "uvmcopy",
      "uvmclear",
      "copyout",
      "copyin",
      "copyinstr"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/vm.c",
    "filename": "vm.c",
    "relpath": "kernel/vm.c",
    "start_line": 1,
    "end_line": 81,
    "length": 81,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Make a direct-map page table for the kernel.\npagetable_t\nkvmmake(void)\n{\n  pagetable_t kpgtbl;\n\n  kpgtbl = (pagetable_t) kalloc();\n  memset(kpgtbl, 0, PGSIZE);\n\n  // uart registers\n  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);\n\n  // virtio mmio disk interface\n  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);\n\n  // PLIC\n  kvmmap(kpgtbl, PLIC, PLIC, 0x4000000, PTE_R | PTE_W);\n\n  // map kernel text executable and read-only.\n  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);\n\n  // map kernel data and the physical RAM we'll make use of.\n  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);\n\n  // map the trampoline for trap entry/exit to\n  // the highest virtual address in the kernel.\n  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);\n\n  // allocate and map a kernel stack for each process.\n  proc_mapstacks(kpgtbl);\n  \n  return kpgtbl;\n}",
    "chunk_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart"
    ],
    "document_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart",
      "walkaddr",
      "kvmmap",
      "walk",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst",
      "uvmalloc",
      "uvmdealloc",
      "freewalk",
      "uvmfree",
      "uvmcopy",
      "uvmclear",
      "copyout",
      "copyin",
      "copyinstr"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/riscv.h",
    "filename": "riscv.h",
    "relpath": "kernel/riscv.h",
    "start_line": 1,
    "end_line": 382,
    "length": 382,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// __ASSEMBLER__\n\n// shift a physical address to the right place for a PTE.\n#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)\n\n#define PTE2PA(pte) (((pte) >> 10) << 12)\n\n#define PTE_FLAGS(pte) ((pte) & 0x3FF)",
    "document_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie",
      "MIE_STIE",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0",
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra",
      "sfence_vma"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/vm.c",
    "filename": "vm.c",
    "relpath": "kernel/vm.c",
    "start_line": 142,
    "end_line": 231,
    "length": 90,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// create an empty user page table.\n// returns 0 if out of memory.\npagetable_t\nuvmcreate()\n{\n  pagetable_t pagetable;\n  pagetable = (pagetable_t) kalloc();\n  if(pagetable == 0)\n    return 0;\n  memset(pagetable, 0, PGSIZE);\n  return pagetable;\n}",
    "chunk_function_names": [
      "mappages",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst"
    ],
    "document_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart",
      "walkaddr",
      "kvmmap",
      "walk",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst",
      "uvmalloc",
      "uvmdealloc",
      "freewalk",
      "uvmfree",
      "uvmcopy",
      "uvmclear",
      "copyout",
      "copyin",
      "copyinstr"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 624,
    "end_line": 695,
    "length": 72,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Copy to either a user address, or kernel address,\n// depending on usr_dst.\n// Returns 0 on success, -1 on error.\nint\neither_copyout(int user_dst, uint64 dst, void *src, uint64 len)\n{\n  struct proc *p = myproc();\n  if(user_dst){\n    return copyout(p->pagetable, dst, src, len);\n  } else {\n    memmove((char *)dst, src, len);\n    return 0;\n  }\n}\n\n// Copy from either a user address, or kernel address,\n// depending on usr_src.\n// Returns 0 on success, -1 on error.\nint\neither_copyin(void *dst, int user_src, uint64 src, uint64 len)\n{\n  struct proc *p = myproc();\n  if(user_src){\n    return copyin(p->pagetable, dst, src, len);\n  } else {\n    memmove(dst, (char*)src, len);\n    return 0;\n  }\n}",
    "chunk_function_names": [
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 107,
    "end_line": 175,
    "length": 69,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// If there are no free procs, or a memory allocation fails, return 0.\nstatic struct proc*\nallocproc(void)\n{\n  struct proc *p;\n\n  for(p = proc; p < &proc[NPROC]; p++) {\n    acquire(&p->lock);\n    if(p->state == UNUSED) {\n      goto found;\n    } else {\n      release(&p->lock);\n    }\n  }\n  return 0;\n\nfound:\n  p->pid = allocpid();\n  p->state = USED;\n\n  // Allocate a trapframe page.\n  if((p->trapframe = (struct trapframe *)kalloc()) == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n\n  // An empty user page table.\n  p->pagetable = proc_pagetable(p);\n  if(p->pagetable == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n\n  // Set up new context to start executing at forkret,\n  // which returns to user space.\n  memset(&p->context, 0, sizeof(p->context));\n  p->context.ra = (uint64)forkret;\n  p->context.sp = p->kstack + PGSIZE;\n\n  return p;\n}\n\n// free a proc structure and the data hanging from it,\n// including user pages.\n// p->lock must be held.\nstatic void\nfreeproc(struct proc *p)\n{\n  if(p->trapframe)\n    kfree((void*)p->trapframe);\n  p->trapframe = 0;\n  if(p->pagetable)\n    proc_freepagetable(p->pagetable, p->sz);\n  p->pagetable = 0;\n  p->sz = 0;\n  p->pid = 0;\n  p->parent = 0;\n  p->name[0] = 0;\n  p->chan = 0;\n  p->killed = 0;\n  p->xstate = 0;\n  p->state = UNUSED;\n}",
    "chunk_function_names": [
      "freeproc"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 175,
    "end_line": 255,
    "length": 81,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "pagetable_t\nproc_pagetable(struct proc *p)\n{\n  pagetable_t pagetable;\n\n  // An empty page table.\n  pagetable = uvmcreate();\n  if(pagetable == 0)\n    return 0;\n\n  // map the trampoline code (for system call return)\n  // at the highest user virtual address.\n  // only the supervisor uses it, on the way\n  // to/from user space, so not PTE_U.\n  if(mappages(pagetable, TRAMPOLINE, PGSIZE,\n              (uint64)trampoline, PTE_R | PTE_X) < 0){\n    uvmfree(pagetable, 0);\n    return 0;\n  }\n\n  // map the trapframe page just below the trampoline page, for\n  // trampoline.S.\n  if(mappages(pagetable, TRAPFRAME, PGSIZE,\n              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){\n    uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n    uvmfree(pagetable, 0);\n    return 0;\n  }\n\n  return pagetable;\n}\n\nvoid\nproc_freepagetable(pagetable_t pagetable, uint64 sz)\n{\n  uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n  uvmunmap(pagetable, TRAPFRAME, 1, 0);\n  uvmfree(pagetable, sz);\n}",
    "chunk_function_names": [
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  }
]