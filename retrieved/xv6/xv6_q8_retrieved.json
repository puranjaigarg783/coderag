[
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/main.c",
    "filename": "main.c",
    "relpath": "kernel/main.c",
    "start_line": 1,
    "end_line": 45,
    "length": 45,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "#include \"types.h\"\n#include \"param.h\"\n#include \"memlayout.h\"\n#include \"riscv.h\"\n#include \"defs.h\"\n\nvolatile static int started = 0;\n\n// start() jumps here in supervisor mode on all CPUs.\nvoid\nmain()\n{\n    kinit();         // physical page allocator\n    kvminit();       // create kernel page table\n    kvminithart();   // turn on paging\n    procinit();      // process table\n    trapinit();      // trap vectors\n    trapinithart();  // install kernel trap vector\n    plicinit();      // set up interrupt controller\n    plicinithart();  // ask PLIC for device interrupts\n    binit();         // buffer cache\n    iinit();         // inode table\n    fileinit();      // file table\n    virtio_disk_init(); // emulated hard disk\n    userinit();      // first user process\n}",
    "chunk_function_names": [
      "main"
    ],
    "document_function_names": [
      "main"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/riscv.h",
    "filename": "riscv.h",
    "relpath": "kernel/riscv.h",
    "start_line": 216,
    "end_line": 341,
    "length": 126,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// supervisor address translation and protection;\n// holds the address of the page table.\nstatic inline void \nw_satp(uint64 x)\n{\n  asm volatile(\"csrw satp, %0\" : : \"r\" (x));\n}\n\nstatic inline uint64\nr_satp()\n{\n  uint64 x;\n  asm volatile(\"csrr %0, satp\" : \"=r\" (x) );\n  return x;\n}\n\n// Supervisor Trap Cause\nstatic inline uint64\nr_scause()\n{\n  uint64 x;\n  asm volatile(\"csrr %0, scause\" : \"=r\" (x) );\n  return x;\n}\n\n// Supervisor Trap Value\nstatic inline uint64\nr_stval()\n{\n  uint64 x;\n  asm volatile(\"csrr %0, stval\" : \"=r\" (x) );\n  return x;\n}\n\n// enable device interrupts\nstatic inline void\nintr_on()\n{\n  w_sstatus(r_sstatus() | SSTATUS_SIE);\n}\n\n// disable device interrupts\nstatic inline void\nintr_off()\n{\n  w_sstatus(r_sstatus() & ~SSTATUS_SIE);\n}\n\n// are device interrupts enabled?\nstatic inline int\nintr_get()\n{\n  uint64 x = r_sstatus();\n  return (x & SSTATUS_SIE) != 0;\n}",
    "chunk_function_names": [
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra"
    ],
    "document_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie",
      "MIE_STIE",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0",
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra",
      "sfence_vma"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/vm.c",
    "filename": "vm.c",
    "relpath": "kernel/vm.c",
    "start_line": 1,
    "end_line": 81,
    "length": 81,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Make a direct-map page table for the kernel.\npagetable_t\nkvmmake(void)\n{\n  pagetable_t kpgtbl;\n\n  kpgtbl = (pagetable_t) kalloc();\n  memset(kpgtbl, 0, PGSIZE);\n\n  // uart registers\n  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);\n\n  // virtio mmio disk interface\n  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);\n\n  // PLIC\n  kvmmap(kpgtbl, PLIC, PLIC, 0x4000000, PTE_R | PTE_W);\n\n  // map kernel text executable and read-only.\n  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);\n\n  // map kernel data and the physical RAM we'll make use of.\n  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);\n\n  // map the trampoline for trap entry/exit to\n  // the highest virtual address in the kernel.\n  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);\n\n  // allocate and map a kernel stack for each process.\n  proc_mapstacks(kpgtbl);\n  \n  return kpgtbl;\n}\n\n// Initialize the one kernel_pagetable\nvoid\nkvminit(void)\n{\n  kernel_pagetable = kvmmake();\n}\n\n// Switch h/w page table register to the kernel's page table,\n// and enable paging.\nvoid\nkvminithart()\n{\n  // wait for any previous writes to the page table memory to finish.\n  sfence_vma();\n\n  w_satp(MAKE_SATP(kernel_pagetable));\n\n  // flush stale entries from the TLB.\n  sfence_vma();\n}",
    "chunk_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart"
    ],
    "document_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart",
      "walkaddr",
      "kvmmap",
      "walk",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst",
      "uvmalloc",
      "uvmdealloc",
      "freewalk",
      "uvmfree",
      "uvmcopy",
      "uvmclear",
      "copyout",
      "copyin",
      "copyinstr"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/start.c",
    "filename": "start.c",
    "relpath": "kernel/start.c",
    "start_line": 1,
    "end_line": 66,
    "length": 66,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "void\nstart()\n{\n  // set M Previous Privilege mode to Supervisor, for mret.\n  unsigned long x = r_mstatus();\n  x &= ~MSTATUS_MPP_MASK;\n  x |= MSTATUS_MPP_S;\n  w_mstatus(x);\n\n  // set M Exception Program Counter to main, for mret.\n  // requires gcc -mcmodel=medany\n  w_mepc((uint64)main);\n\n  // disable paging for now.\n  w_satp(0);\n\n  // delegate all interrupts and exceptions to supervisor mode.\n  w_medeleg(0xffff);\n  w_mideleg(0xffff);\n  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);\n\n  // configure Physical Memory Protection to give supervisor mode\n  // access to all of physical memory.\n  w_pmpaddr0(0x3fffffffffffffull);\n  w_pmpcfg0(0xf);\n\n  // ask for clock interrupts.\n  timerinit();\n\n  // keep each CPU's hartid in its tp register, for cpuid().\n  int id = r_mhartid();\n  w_tp(id);\n\n  // switch to supervisor mode and jump to main().\n  asm volatile(\"mret\");\n}\n\n// ask each hart to generate timer interrupts.\nvoid\ntimerinit()\n{\n  // enable supervisor-mode timer interrupts.\n  w_mie(r_mie() | MIE_STIE);\n  \n  // enable the sstc extension (i.e. stimecmp).\n  w_menvcfg(r_menvcfg() | (1L << 63)); \n  \n  // allow supervisor to use stimecmp and time.\n  w_mcounteren(r_mcounteren() | 2);\n  \n  // ask for the very first timer interrupt.\n  w_stimecmp(r_time() + 1000000);\n}",
    "chunk_function_names": [
      "start",
      "timerinit"
    ],
    "document_function_names": [
      "start",
      "timerinit"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/sysproc.c",
    "filename": "sysproc.c",
    "relpath": "kernel/sysproc.c",
    "start_line": 1,
    "end_line": 93,
    "length": 93,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// return how many clock tick interrupts have occurred\n// since start.\nuint64\nsys_uptime(void)\n{\n  uint xticks;\n\n  acquire(&tickslock);\n  xticks = ticks;\n  release(&tickslock);\n  return xticks;\n}",
    "chunk_function_names": [
      "sys_exit",
      "sys_getpid",
      "sys_fork",
      "sys_wait",
      "sys_sbrk",
      "sys_sleep",
      "sys_kill",
      "sys_uptime"
    ],
    "document_function_names": [
      "sys_exit",
      "sys_getpid",
      "sys_fork",
      "sys_wait",
      "sys_sbrk",
      "sys_sleep",
      "sys_kill",
      "sys_uptime"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 1,
    "end_line": 107,
    "length": 107,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "#include \"types.h\"\n#include \"param.h\"\n#include \"memlayout.h\"\n#include \"riscv.h\"\n#include \"spinlock.h\"\n#include \"proc.h\"\n#include \"defs.h\"\n\nstruct proc proc[NPROC];\n\nstruct proc *initproc;\n\nextern char trampoline[]; // trampoline.S\n\n// helps ensure that wakeups of wait()ing\n// parents are not lost. helps obey the\n// memory model when using p->parent.\n// must be acquired before any p->lock.\nstruct spinlock wait_lock;\n\n// Allocate a page for each process's kernel stack.\n// Map it high in memory, followed by an invalid\n// guard page.\nvoid\nproc_mapstacks(pagetable_t kpgtbl)\n{\n  struct proc *p;\n  \n  for(p = proc; p < &proc[NPROC]; p++) {\n    char *pa = kalloc();\n    if(pa == 0)\n      panic(\"kalloc\");\n    uint64 va = KSTACK((int) (p - proc));\n    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);\n  }\n}\n\n// initialize the proc table.\nvoid\nprocinit(void)\n{\n  struct proc *p;\n  \n  initlock(&wait_lock, \"wait_lock\");\n  for(p = proc; p < &proc[NPROC]; p++) {\n      initlock(&p->lock, \"proc\");\n      p->state = UNUSED;\n      p->kstack = KSTACK((int) (p - proc));\n  }\n}\n\n// Must be called with interrupts disabled,\n// to prevent race with process being moved\n// to a different CPU.\nint\ncpuid()\n{\n  int id = r_tp();\n  return id;\n}\n\n// Return this CPU's cpu struct.\n// Interrupts must be disabled.\nstruct cpu*\nmycpu(void)\n{\n  int id = cpuid();\n  struct cpu *c = &cpus[id];\n  return c;\n}\n\n// Return the current struct proc *, or zero if none.\nstruct proc*\nmyproc(void)\n{\n  push_off();\n  struct cpu *c = mycpu();\n  struct proc *p = c->proc;\n  pop_off();\n  return p;\n}\n\nint\nallocpid()\n{\n  int pid;\n  \n  acquire(&pid_lock);\n  pid = nextpid;\n  nextpid = nextpid + 1;\n  release(&pid_lock);\n\n  return pid;\n}",
    "chunk_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 175,
    "end_line": 255,
    "length": 81,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Set up first user process.\nvoid\nuserinit(void)\n{\n  struct proc *p;\n\n  p = allocproc();\n  initproc = p;\n  \n  // allocate one user page and copy initcode's instructions\n  // and data into it.\n  uvmfirst(p->pagetable, initcode, sizeof(initcode));\n  p->sz = PGSIZE;\n\n  // prepare for the very first \"return\" from kernel to user.\n  p->trapframe->epc = 0;      // user program counter\n  p->trapframe->sp = PGSIZE;  // user stack pointer\n\n  safestrcpy(p->name, \"initcode\", sizeof(p->name));\n  p->cwd = namei(\"/\");\n\n  p->state = RUNNABLE;\n\n  release(&p->lock);\n}",
    "chunk_function_names": [
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 522,
    "end_line": 624,
    "length": 103,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "void\nforkret(void)\n{\n  static int first = 1;\n\n  // Still holding p->lock from scheduler.\n  release(&myproc()->lock);\n\n  if (first) {\n    // File system initialization must be run in the context of a\n    // regular process (e.g., because it calls sleep), and thus cannot\n    // be run from main().\n    fsinit(ROOTDEV);\n\n    first = 0;\n    // ensure other cores see first=0.\n    __sync_synchronize();\n  }\n\n  usertrapret();\n}\n\n// Atomically release lock and sleep on chan.\n// Reacquires lock when awakened.\nvoid\nsleep(void *chan, struct spinlock *lk)\n{\n  struct proc *p = myproc();\n  \n  // Must acquire p->lock in order to\n  // change p->state and then call sched.\n  // Once we hold p->lock, we can be\n  // guaranteed that we won't miss any wakeup\n  // (wakeup locks p->lock),\n  // so it's okay to release lk.\n\n  acquire(&p->lock);  //DOC: sleeplock1\n  release(lk);\n\n  // Go to sleep.\n  p->chan = chan;\n  p->state = SLEEPING;\n\n  sched();\n\n  // Tidy up.\n  p->chan = 0;\n\n  // Reacquire original lock.\n  release(&p->lock);\n  acquire(lk);\n}\n\n// Wake up all processes sleeping on chan.\n// Must be called without any p->lock.\nvoid\nwakeup(void *chan)\n{\n  struct proc *p;\n\n  for(p = proc; p < &proc[NPROC]; p++) {\n    if(p != myproc()){\n      acquire(&p->lock);\n      if(p->state == SLEEPING && p->chan == chan) {\n        p->state = RUNNABLE;\n      }\n      release(&p->lock);\n    }\n  }\n}",
    "chunk_function_names": [
      "forkret",
      "sleep",
      "wakeup",
      "space",
      "setkilled"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/memlayout.h",
    "filename": "memlayout.h",
    "relpath": "kernel/memlayout.h",
    "start_line": 1,
    "end_line": 59,
    "length": 59,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Physical memory layout\n\n// qemu -machine virt is set up like this,\n// based on qemu's hw/riscv/virt.c:\n//\n// 00001000 -- boot ROM, provided by qemu\n// 02000000 -- CLINT\n// 0C000000 -- PLIC\n// 10000000 -- uart0 \n// 10001000 -- virtio disk \n// 80000000 -- boot ROM jumps here in machine mode\n//             -kernel loads the kernel here\n// unused RAM after 80000000.\n\n// the kernel uses physical memory thus:\n// 80000000 -- entry.S, then kernel text and data\n// end -- start of kernel page allocation area\n// PHYSTOP -- end RAM used by the kernel\n\n// qemu puts UART registers here in physical memory.\n#define UART0 0x10000000L\n#define UART0_IRQ 10\n\n// virtio mmio interface\n#define VIRTIO0 0x10001000\n#define VIRTIO0_IRQ 1\n\n// qemu puts platform-level interrupt controller (PLIC) here.\n#define PLIC 0x0c000000L\n#define PLIC_PRIORITY (PLIC + 0x0)\n#define PLIC_PENDING (PLIC + 0x1000)\n#define PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)\n#define PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)\n#define PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)"
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/riscv.h",
    "filename": "riscv.h",
    "relpath": "kernel/riscv.h",
    "start_line": 1,
    "end_line": 100,
    "length": 100,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Machine Status Register, mstatus\n\n#define MSTATUS_MPP_MASK (3L << 11) // previous mode.\n#define MSTATUS_MPP_M (3L << 11)\n#define MSTATUS_MPP_S (1L << 11)\n#define MSTATUS_MPP_U (0L << 11)\n#define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.\n\nstatic inline uint64\nr_mstatus()\n{\n  uint64 x;\n  asm volatile(\"csrr %0, mstatus\" : \"=r\" (x) );\n  return x;\n}\n\nstatic inline void \nw_mstatus(uint64 x)\n{\n  asm volatile(\"csrw mstatus, %0\" : : \"r\" (x));\n}\n\nstatic inline void \nw_mepc(uint64 x)\n{\n  asm volatile(\"csrw mepc, %0\" : : \"r\" (x));\n}",
    "chunk_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie"
    ],
    "document_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie",
      "MIE_STIE",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0",
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra",
      "sfence_vma"
    ]
  }
]