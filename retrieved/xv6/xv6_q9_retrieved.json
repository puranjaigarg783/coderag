[
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 175,
    "end_line": 255,
    "length": 81,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Set up first user process.\nvoid\nuserinit(void)\n{\n  struct proc *p;\n\n  p = allocproc();\n  initproc = p;\n  \n  // allocate one user page and copy initcode's instructions\n  // and data into it.\n  uvmfirst(p->pagetable, initcode, sizeof(initcode));\n  p->sz = PGSIZE;\n\n  // prepare for the very first \"return\" from kernel to user.\n  p->trapframe->epc = 0;      // user program counter\n  p->trapframe->sp = PGSIZE;  // user stack pointer\n\n  safestrcpy(p->name, \"initcode\", sizeof(p->name));\n  p->cwd = namei(\"/\");\n\n  p->state = RUNNABLE;\n\n  release(&p->lock);\n}",
    "chunk_function_names": [
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 255,
    "end_line": 345,
    "length": 91,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "int\nfork(void)\n{\n  int i, pid;\n  struct proc *np;\n  struct proc *p = myproc();\n\n  // Allocate process.\n  if((np = allocproc()) == 0){\n    return -1;\n  }\n\n  // Copy user memory from parent to child.\n  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){\n    freeproc(np);\n    release(&np->lock);\n    return -1;\n  }\n  np->sz = p->sz;\n\n  // copy saved user registers.\n  *(np->trapframe) = *(p->trapframe);\n\n  // Cause fork to return 0 in the child.\n  np->trapframe->a0 = 0;\n\n  // increment reference counts on open file descriptors.\n  for(i = 0; i < NOFILE; i++)\n    if(p->ofile[i])\n      np->ofile[i] = filedup(p->ofile[i]);\n  np->cwd = idup(p->cwd);\n\n  safestrcpy(np->name, p->name, sizeof(p->name));\n\n  pid = np->pid;\n\n  release(&np->lock);\n\n  acquire(&wait_lock);\n  np->parent = p;\n  release(&wait_lock);\n\n  acquire(&np->lock);\n  np->state = RUNNABLE;\n  release(&np->lock);\n\n  return pid;\n}",
    "chunk_function_names": [
      "growproc",
      "fork",
      "reparent"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/exec.c",
    "filename": "exec.c",
    "relpath": "kernel/exec.c",
    "start_line": 23,
    "end_line": 105,
    "length": 83,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "{\n  char *s, *last;\n  int i, off;\n  uint64 argc, sz = 0, sp, ustack[MAXARG], stackbase;\n  struct elfhdr elf;\n  struct inode *ip;\n  struct proghdr ph;\n  pagetable_t pagetable = 0, oldpagetable;\n  struct proc *p = myproc();\n\n  begin_op();\n\n  if((ip = namei(path)) == 0){\n    end_op();\n    return -1;\n  }\n  ilock(ip);\n\n  // Check ELF header\n  if(readi(ip, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf))\n    goto bad;\n\n  if(elf.magic != ELF_MAGIC)\n    goto bad;\n\n  if((pagetable = proc_pagetable(p)) == 0)\n    goto bad;\n\n  // Load program into memory.\n  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){\n    if(readi(ip, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph))\n      goto bad;\n    if(ph.type != ELF_PROG_LOAD)\n      continue;\n    if(ph.memsz < ph.filesz)\n      goto bad;\n    if(ph.vaddr + ph.memsz < ph.vaddr)\n      goto bad;\n    if(ph.vaddr % PGSIZE != 0)\n      goto bad;\n    uint64 sz1;\n    if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == 0)\n      goto bad;\n    sz = sz1;\n    if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0)\n      goto bad;\n  }\n  iunlockput(ip);\n  end_op();\n  ip = 0;\n\n  p = myproc();\n  uint64 oldsz = p->sz;\n\n  // Allocate some pages at the next page boundary.\n  // Make the first inaccessible as a stack guard.\n  // Use the rest as the user stack.\n  sz = PGROUNDUP(sz);\n  uint64 sz1;\n  if((sz1 = uvmalloc(pagetable, sz, sz + (USERSTACK+1)*PGSIZE, PTE_W)) == 0)\n    goto bad;\n  sz = sz1;\n  uvmclear(pagetable, sz-(USERSTACK+1)*PGSIZE);\n  sp = sz;\n  stackbase = sp - USERSTACK*PGSIZE;\n\n  // Push argument strings, prepare rest of stack in ustack.\n  for(argc = 0; argv[argc]; argc++) {\n    if(argc >= MAXARG)\n      goto bad;\n    sp -= strlen(argv[argc]) + 1;\n    sp -= sp % 16; // riscv sp must be 16-byte aligned\n    if(sp < stackbase)\n      goto bad;\n    if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) < 0)\n      goto bad;\n    ustack[argc] = sp;\n  }\n  ustack[argc] = 0;\n\n  // push the array of argv[] pointers.\n  sp -= (argc+1) * sizeof(uint64);\n}",
    "document_function_names": [
      "flags2perm",
      "exec",
      "loadseg"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/main.c",
    "filename": "main.c",
    "relpath": "kernel/main.c",
    "start_line": 1,
    "end_line": 45,
    "length": 45,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// start() jumps here in supervisor mode on all CPUs.\nvoid\nmain()\n{\n    userinit();      // first user process\n}",
    "chunk_function_names": [
      "main"
    ],
    "document_function_names": [
      "main"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/exec.c",
    "filename": "exec.c",
    "relpath": "kernel/exec.c",
    "start_line": 105,
    "end_line": 141,
    "length": 37,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// arguments to user main(argc, argv)\n// argc is returned via the system call return\n// value, which goes in a0.\np->trapframe->a1 = sp;\n\n// Save program name for debugging.\nfor(last=s=path; *s; s++)\n  if(*s == '/')\n    last = s+1;\nsafestrcpy(p->name, last, sizeof(p->name));\n\n// Commit to the user image.\noldpagetable = p->pagetable;\np->pagetable = pagetable;\np->sz = sz;\np->trapframe->epc = elf.entry;  // initial program counter = main\np->trapframe->sp = sp; // initial stack pointer\nproc_freepagetable(oldpagetable, oldsz);\n\nreturn argc; // this ends up in a0, the first argument to main(argc, argv)\n\nbad:\nif(pagetable)\n  proc_freepagetable(pagetable, sz);\nif(ip){\n  iunlockput(ip);\n  end_op();\n}\nreturn -1;",
    "document_function_names": [
      "flags2perm",
      "exec",
      "loadseg"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 107,
    "end_line": 175,
    "length": 69,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// If there are no free procs, or a memory allocation fails, return 0.\nstatic struct proc*\nallocproc(void)\n{\n  struct proc *p;\n\n  for(p = proc; p < &proc[NPROC]; p++) {\n    acquire(&p->lock);\n    if(p->state == UNUSED) {\n      goto found;\n    } else {\n      release(&p->lock);\n    }\n  }\n  return 0;\n\nfound:\n  p->pid = allocpid();\n  p->state = USED;\n\n  // Allocate a trapframe page.\n  if((p->trapframe = (struct trapframe *)kalloc()) == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n\n  // An empty user page table.\n  p->pagetable = proc_pagetable(p);\n  if(p->pagetable == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n\n  // Set up new context to start executing at forkret,\n  // which returns to user space.\n  memset(&p->context, 0, sizeof(p->context));\n  p->context.ra = (uint64)forkret;\n  p->context.sp = p->kstack + PGSIZE;\n\n  return p;\n}\n\n// free a proc structure and the data hanging from it,\n// including user pages.\n// p->lock must be held.\nstatic void\nfreeproc(struct proc *p)\n{\n  if(p->trapframe)\n    kfree((void*)p->trapframe);\n  p->trapframe = 0;\n  if(p->pagetable)\n    proc_freepagetable(p->pagetable, p->sz);\n  p->pagetable = 0;\n  p->sz = 0;\n  p->pid = 0;\n  p->parent = 0;\n  p->name[0] = 0;\n  p->chan = 0;\n  p->killed = 0;\n  p->xstate = 0;\n  p->state = UNUSED;\n}",
    "chunk_function_names": [
      "freeproc"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/riscv.h",
    "filename": "riscv.h",
    "relpath": "kernel/riscv.h",
    "start_line": 216,
    "end_line": 341,
    "length": 126,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Supervisor Trap Cause\nstatic inline uint64\nr_scause()\n{\n  uint64 x;\n  asm volatile(\"csrr %0, scause\" : \"=r\" (x) );\n  return x;\n}\n\n// Supervisor Trap Value\nstatic inline uint64\nr_stval()\n{\n  uint64 x;\n  asm volatile(\"csrr %0, stval\" : \"=r\" (x) );\n  return x;\n}\n\n// read and write tp, the thread pointer, which xv6 uses to hold\n// this core's hartid (core number), the index into cpus[].\nstatic inline uint64\nr_tp()\n{\n  uint64 x;\n  asm volatile(\"mv %0, tp\" : \"=r\" (x) );\n  return x;\n}\n\nstatic inline void \nw_tp(uint64 x)\n{\n  asm volatile(\"mv tp, %0\" : : \"r\" (x));\n}",
    "chunk_function_names": [
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra"
    ],
    "document_function_names": [
      "hart",
      "MSTATUS_MPP_MASK",
      "w_mstatus",
      "w_mepc",
      "SSTATUS_SPP",
      "w_sstatus",
      "r_sip",
      "w_sip",
      "SIE_SEIE",
      "w_sie",
      "MIE_STIE",
      "w_mie",
      "w_sepc",
      "r_sepc",
      "r_medeleg",
      "w_medeleg",
      "r_mideleg",
      "w_mideleg",
      "w_stvec",
      "r_stvec",
      "r_stimecmp",
      "w_stimecmp",
      "r_menvcfg",
      "w_menvcfg",
      "w_pmpcfg0",
      "w_pmpaddr0",
      "w_satp",
      "r_satp",
      "r_scause",
      "r_stval",
      "w_mcounteren",
      "r_mcounteren",
      "r_time",
      "intr_on",
      "intr_off",
      "intr_get",
      "r_sp",
      "hartid",
      "w_tp",
      "r_ra",
      "sfence_vma"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 522,
    "end_line": 624,
    "length": 103,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "void\nforkret(void)\n{\n  static int first = 1;\n\n  // Still holding p->lock from scheduler.\n  release(&myproc()->lock);\n\n  if (first) {\n    fsinit(ROOTDEV);\n\n    first = 0;\n    __sync_synchronize();\n  }\n\n  usertrapret();\n}",
    "chunk_function_names": [
      "forkret",
      "sleep",
      "wakeup",
      "space",
      "setkilled"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 1,
    "end_line": 107,
    "length": 107,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "#include \"types.h\"\n#include \"param.h\"\n#include \"memlayout.h\"\n#include \"riscv.h\"\n#include \"spinlock.h\"\n#include \"proc.h\"\n#include \"defs.h\"\n\nstruct cpu cpus[NCPU];\n\nstruct proc proc[NPROC];\n\nstruct proc *initproc;\n\nint nextpid = 1;\nstruct spinlock pid_lock;\n\nextern void forkret(void);\nstatic void freeproc(struct proc *p);\n\nextern char trampoline[]; // trampoline.S\n\n// helps ensure that wakeups of wait()ing\n// parents are not lost. helps obey the\n// memory model when using p->parent.\n// must be acquired before any p->lock.\nstruct spinlock wait_lock;\n\n// Allocate a page for each process's kernel stack.\n// Map it high in memory, followed by an invalid\n// guard page.\nvoid\nproc_mapstacks(pagetable_t kpgtbl)\n{\n  struct proc *p;\n  \n  for(p = proc; p < &proc[NPROC]; p++) {\n    char *pa = kalloc();\n    if(pa == 0)\n      panic(\"kalloc\");\n    uint64 va = KSTACK((int) (p - proc));\n    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);\n  }\n}\n\n// initialize the proc table.\nvoid\nprocinit(void)\n{\n  struct proc *p;\n  \n  initlock(&pid_lock, \"nextpid\");\n  initlock(&wait_lock, \"wait_lock\");\n  for(p = proc; p < &proc[NPROC]; p++) {\n      initlock(&p->lock, \"proc\");\n      p->state = UNUSED;\n      p->kstack = KSTACK((int) (p - proc));\n  }\n}\n\n// Must be called with interrupts disabled,\n// to prevent race with process being moved\n// to a different CPU.\nint\ncpuid()\n{\n  int id = r_tp();\n  return id;\n}\n\n// Return this CPU's cpu struct.\n// Interrupts must be disabled.\nstruct cpu*\nmycpu(void)\n{\n  int id = cpuid();\n  struct cpu *c = &cpus[id];\n  return c;\n}\n\n// Return the current struct proc *, or zero if none.\nstruct proc*\nmyproc(void)\n{\n  push_off();\n  struct cpu *c = mycpu();\n  struct proc *p = c->proc;\n  pop_off();\n  return p;\n}\n\nint\nallocpid()\n{\n  int pid;\n  \n  acquire(&pid_lock);\n  pid = nextpid;\n  nextpid = nextpid + 1;\n  release(&pid_lock);\n\n  return pid;\n}",
    "chunk_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/vm.c",
    "filename": "vm.c",
    "relpath": "kernel/vm.c",
    "start_line": 142,
    "end_line": 231,
    "length": 90,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Load the user initcode into address 0 of pagetable,\n// for the very first process.\n// sz must be less than a page.\nvoid\nuvmfirst(pagetable_t pagetable, uchar *src, uint sz)\n{\n  char *mem;\n\n  if(sz >= PGSIZE)\n    panic(\"uvmfirst: more than a page\");\n  mem = kalloc();\n  memset(mem, 0, PGSIZE);\n  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);\n  memmove(mem, src, sz);\n}",
    "chunk_function_names": [
      "mappages",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst"
    ],
    "document_function_names": [
      "kvmmake",
      "kvminit",
      "kvminithart",
      "walkaddr",
      "kvmmap",
      "walk",
      "uvmunmap",
      "uvmcreate",
      "uvmfirst",
      "uvmalloc",
      "uvmdealloc",
      "freewalk",
      "uvmfree",
      "uvmcopy",
      "uvmclear",
      "copyout",
      "copyin",
      "copyinstr"
    ]
  }
]