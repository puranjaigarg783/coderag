[
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/sysfile.c",
    "filename": "sysfile.c",
    "relpath": "kernel/sysfile.c",
    "start_line": 302,
    "end_line": 407,
    "length": 106,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "uint64\nsys_open(void)\n{\n  char path[MAXPATH];\n  int fd, omode;\n  struct file *f;\n  struct inode *ip;\n  int n;\n\n  argint(1, &omode);\n  if((n = argstr(0, path, MAXPATH)) < 0)\n    return -1;\n\n  begin_op();\n\n  if(omode & O_CREATE){\n    ip = create(path, T_FILE, 0, 0);\n    if(ip == 0){\n      end_op();\n      return -1;\n    }\n  } else {\n    if((ip = namei(path)) == 0){\n      end_op();\n      return -1;\n    }\n    ilock(ip);\n    if(ip->type == T_DIR && omode != O_RDONLY){\n      iunlockput(ip);\n      end_op();\n      return -1;\n    }\n  }\n\n  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n\n  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){\n    if(f)\n      fileclose(f);\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n\n  if(ip->type == T_DEVICE){\n    f->type = FD_DEVICE;\n    f->major = ip->major;\n  } else {\n    f->type = FD_INODE;\n    f->off = 0;\n  }\n  f->ip = ip;\n  f->readable = !(omode & O_WRONLY);\n  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);\n\n  if((omode & O_TRUNC) && ip->type == T_FILE){\n    itrunc(ip);\n  }\n\n  iunlock(ip);\n  end_op();\n\n  return fd;\n}",
    "chunk_function_names": [
      "sys_open",
      "sys_mkdir",
      "sys_mknod"
    ],
    "document_function_names": [
      "argfd",
      "fdalloc",
      "sys_dup",
      "sys_read",
      "sys_write",
      "sys_close",
      "sys_fstat",
      "sys_link",
      "isdirempty",
      "sys_unlink",
      "sys_open",
      "sys_mkdir",
      "sys_mknod",
      "sys_chdir",
      "sys_exec",
      "sys_pipe"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/sysfile.c",
    "filename": "sysfile.c",
    "relpath": "kernel/sysfile.c",
    "start_line": 1,
    "end_line": 122,
    "length": 122,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Fetch the nth word-sized system call argument as a file descriptor\n// and return both the descriptor and the corresponding struct file.\nstatic int\nargfd(int n, int *pfd, struct file **pf)\n{\n  int fd;\n  struct file *f;\n\n  argint(n, &fd);\n  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)\n    return -1;\n  if(pfd)\n    *pfd = fd;\n  if(pf)\n    *pf = f;\n  return 0;\n}\n\n// Allocate a file descriptor for the given file.\n// Takes over file reference from caller on success.\nstatic int\nfdalloc(struct file *f)\n{\n  int fd;\n  struct proc *p = myproc();\n\n  for(fd = 0; fd < NOFILE; fd++){\n    if(p->ofile[fd] == 0){\n      p->ofile[fd] = f;\n      return fd;\n    }\n  }\n  return -1;\n}\n\nuint64\nsys_dup(void)\n{\n  struct file *f;\n  int fd;\n\n  if(argfd(0, 0, &f) < 0)\n    return -1;\n  if((fd=fdalloc(f)) < 0)\n    return -1;\n  filedup(f);\n  return fd;\n}\n\nuint64\nsys_read(void)\n{\n  struct file *f;\n  int n;\n  uint64 p;\n\n  argaddr(1, &p);\n  argint(2, &n);\n  if(argfd(0, 0, &f) < 0)\n    return -1;\n  return fileread(f, p, n);\n}\n\nuint64\nsys_write(void)\n{\n  struct file *f;\n  int n;\n  uint64 p;\n  \n  argaddr(1, &p);\n  argint(2, &n);\n  if(argfd(0, 0, &f) < 0)\n    return -1;\n\n  return filewrite(f, p, n);\n}\n\nuint64\nsys_close(void)\n{\n  int fd;\n  struct file *f;\n\n  if(argfd(0, &fd, &f) < 0)\n    return -1;\n  myproc()->ofile[fd] = 0;\n  fileclose(f);\n  return 0;\n}\n\nuint64\nsys_fstat(void)\n{\n  struct file *f;\n  uint64 st; // user pointer to struct stat\n\n  argaddr(1, &st);\n  if(argfd(0, 0, &f) < 0)\n    return -1;\n  return filestat(f, st);\n}",
    "chunk_function_names": [
      "argfd",
      "fdalloc",
      "sys_dup",
      "sys_read",
      "sys_write",
      "sys_close",
      "sys_fstat"
    ],
    "document_function_names": [
      "argfd",
      "fdalloc",
      "sys_dup",
      "sys_read",
      "sys_write",
      "sys_close",
      "sys_fstat",
      "sys_link",
      "isdirempty",
      "sys_unlink",
      "sys_open",
      "sys_mkdir",
      "sys_mknod",
      "sys_chdir",
      "sys_exec",
      "sys_pipe"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/sysfile.c",
    "filename": "sysfile.c",
    "relpath": "kernel/sysfile.c",
    "start_line": 407,
    "end_line": 505,
    "length": 99,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "uint64\nsys_pipe(void)\n{\n  uint64 fdarray; // user pointer to array of two integers\n  struct file *rf, *wf;\n  int fd0, fd1;\n  struct proc *p = myproc();\n\n  argaddr(0, &fdarray);\n  if(pipealloc(&rf, &wf) < 0)\n    return -1;\n  fd0 = -1;\n  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){\n    if(fd0 >= 0)\n      p->ofile[fd0] = 0;\n    fileclose(rf);\n    fileclose(wf);\n    return -1;\n  }\n  if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||\n     copyout(p->pagetable, fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){\n    p->ofile[fd0] = 0;\n    p->ofile[fd1] = 0;\n    fileclose(rf);\n    fileclose(wf);\n    return -1;\n  }\n  return 0;\n}",
    "chunk_function_names": [
      "sys_chdir",
      "sys_exec",
      "sys_pipe"
    ],
    "document_function_names": [
      "argfd",
      "fdalloc",
      "sys_dup",
      "sys_read",
      "sys_write",
      "sys_close",
      "sys_fstat",
      "sys_link",
      "isdirempty",
      "sys_unlink",
      "sys_open",
      "sys_mkdir",
      "sys_mknod",
      "sys_chdir",
      "sys_exec",
      "sys_pipe"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/user/user.h",
    "filename": "user.h",
    "relpath": "user/user.h",
    "start_line": 1,
    "end_line": 43,
    "length": 43,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "int open(const char*, int);"
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/defs.h",
    "filename": "defs.h",
    "relpath": "kernel/defs.h",
    "start_line": 130,
    "end_line": 188,
    "length": 59,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// syscall.c\nvoid            argint(int, int*);\nint             argstr(int, char*, int);\nvoid            argaddr(int, uint64 *);\nint             fetchstr(uint64, char*, int);\nint             fetchaddr(uint64, uint64*);\nvoid            syscall();"
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/file.c",
    "filename": "file.c",
    "relpath": "kernel/file.c",
    "start_line": 1,
    "end_line": 105,
    "length": 105,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Support functions for system calls that involve file descriptors.\n\n#include \"types.h\"\n#include \"riscv.h\"\n#include \"defs.h\"\n#include \"param.h\"\n#include \"fs.h\"\n#include \"spinlock.h\"\n#include \"sleeplock.h\"\n#include \"file.h\"\n#include \"stat.h\"\n#include \"proc.h\"\n\nstruct devsw devsw[NDEV];\nstruct {\n  struct spinlock lock;\n  struct file file[NFILE];\n} ftable;\n\nvoid\nfileinit(void)\n{\n  initlock(&ftable.lock, \"ftable\");\n}\n\n// Allocate a file structure.\nstruct file*\nfilealloc(void)\n{\n  struct file *f;\n\n  acquire(&ftable.lock);\n  for(f = ftable.file; f < ftable.file + NFILE; f++){\n    if(f->ref == 0){\n      f->ref = 1;\n      release(&ftable.lock);\n      return f;\n    }\n  }\n  release(&ftable.lock);\n  return 0;\n}\n\n// Increment ref count for file f.\nstruct file*\nfiledup(struct file *f)\n{\n  acquire(&ftable.lock);\n  if(f->ref < 1)\n    panic(\"filedup\");\n  f->ref++;\n  release(&ftable.lock);\n  return f;\n}\n\n// Close file f.  (Decrement ref count, close when reaches 0.)\nvoid\nfileclose(struct file *f)\n{\n  struct file ff;\n\n  acquire(&ftable.lock);\n  if(f->ref < 1)\n    panic(\"fileclose\");\n  if(--f->ref > 0){\n    release(&ftable.lock);\n    return;\n  }\n  ff = *f;\n  f->ref = 0;\n  f->type = FD_NONE;\n  release(&ftable.lock);\n\n  if(ff.type == FD_PIPE){\n    pipeclose(ff.pipe, ff.writable);\n  } else if(ff.type == FD_INODE || ff.type == FD_DEVICE){\n    begin_op();\n    iput(ff.ip);\n    end_op();\n  }\n}\n\n// Get metadata about file f.\n// addr is a user virtual address, pointing to a struct stat.\nint\nfilestat(struct file *f, uint64 addr)\n{\n  struct proc *p = myproc();\n  struct stat st;\n  \n  if(f->type == FD_INODE || f->type == FD_DEVICE){\n    ilock(f->ip);\n    stati(f->ip, &st);\n    iunlock(f->ip);\n    if(copyout(p->pagetable, addr, (char *)&st, sizeof(st)) < 0)\n      return -1;\n    return 0;\n  }\n  return -1;\n}",
    "chunk_function_names": [
      "fileinit",
      "fileclose",
      "filestat"
    ],
    "document_function_names": [
      "fileinit",
      "fileclose",
      "filestat",
      "fileread",
      "filewrite"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/defs.h",
    "filename": "defs.h",
    "relpath": "kernel/defs.h",
    "start_line": 1,
    "end_line": 73,
    "length": 73,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// fs.c\nvoid            fsinit(int);\nint             dirlink(struct inode*, char*, uint);\nstruct inode*   dirlookup(struct inode*, char*, uint*);\nstruct inode*   ialloc(uint, short);\nstruct inode*   idup(struct inode*);\nvoid            iinit();\nvoid            ilock(struct inode*);\nvoid            iput(struct inode*);\nvoid            iunlock(struct inode*);\nvoid            iunlockput(struct inode*);\nvoid            iupdate(struct inode*);\nint             namecmp(const char*, const char*);\nstruct inode*   namei(char*);\nstruct inode*   nameiparent(char*, char*);\nint             readi(struct inode*, int, uint64, uint, uint);\nvoid            stati(struct inode*, struct stat*);\nint             writei(struct inode*, int, uint64, uint, uint);\nvoid            itrunc(struct inode*);"
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/defs.h",
    "filename": "defs.h",
    "relpath": "kernel/defs.h",
    "start_line": 73,
    "end_line": 130,
    "length": 58,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// swtch.S\nvoid            swtch(struct context*, struct context*);"
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/sysfile.c",
    "filename": "sysfile.c",
    "relpath": "kernel/sysfile.c",
    "start_line": 122,
    "end_line": 243,
    "length": 122,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "uint64\nsys_link(void)\n{\n  char name[DIRSIZ], new[MAXPATH], old[MAXPATH];\n  struct inode *dp, *ip;\n\n  if(argstr(0, old, MAXPATH) < 0 || argstr(1, new, MAXPATH) < 0)\n    return -1;\n\n  begin_op();\n  if((ip = namei(old)) == 0){\n    end_op();\n    return -1;\n  }\n\n  ilock(ip);\n  if(ip->type == T_DIR){\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n\n  ip->nlink++;\n  iupdate(ip);\n  iunlock(ip);\n\n  if((dp = nameiparent(new, name)) == 0)\n    goto bad;\n  ilock(dp);\n  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){\n    iunlockput(dp);\n    goto bad;\n  }\n  iunlockput(dp);\n  iput(ip);\n\n  end_op();\n\n  return 0;\n\nbad:\n  ilock(ip);\n  ip->nlink--;\n  iupdate(ip);\n  iunlockput(ip);\n  end_op();\n  return -1;\n}\n\nuint64\nsys_unlink(void)\n{\n  struct inode *ip, *dp;\n  struct dirent de;\n  char name[DIRSIZ], path[MAXPATH];\n  uint off;\n\n  if(argstr(0, path, MAXPATH) < 0)\n    return -1;\n\n  begin_op();\n  if((dp = nameiparent(path, name)) == 0){\n    end_op();\n    return -1;\n  }\n\n  ilock(dp);\n\n  // Cannot unlink \".\" or \"..\".\n  if(namecmp(name, \".\") == 0 || namecmp(name, \"..\") == 0)\n    goto bad;\n\n  if((ip = dirlookup(dp, name, &off)) == 0)\n    goto bad;\n  ilock(ip);\n\n  if(ip->nlink < 1)\n    panic(\"unlink: nlink < 1\");\n  if(ip->type == T_DIR && !isdirempty(ip)){\n    iunlockput(ip);\n    goto bad;\n  }\n\n  memset(&de, 0, sizeof(de));\n  if(writei(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))\n    panic(\"unlink: writei\");\n  if(ip->type == T_DIR){\n    dp->nlink--;\n    iupdate(dp);\n  }\n  iunlockput(dp);\n\n  ip->nlink--;\n  iupdate(ip);\n  iunlockput(ip);\n\n  end_op();\n\n  return 0;\n\nbad:\n  iunlockput(dp);\n  end_op();\n  return -1;\n}",
    "chunk_function_names": [
      "sys_link",
      "isdirempty",
      "sys_unlink"
    ],
    "document_function_names": [
      "argfd",
      "fdalloc",
      "sys_dup",
      "sys_read",
      "sys_write",
      "sys_close",
      "sys_fstat",
      "sys_link",
      "isdirempty",
      "sys_unlink",
      "sys_open",
      "sys_mkdir",
      "sys_mknod",
      "sys_chdir",
      "sys_exec",
      "sys_pipe"
    ]
  },
  {
    "filepath": "/home/puranjai-garg/Projects/usfca/project02-ragnarok/data/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 255,
    "end_line": 345,
    "length": 91,
    "language": "c",
    "codebase": "xv6",
    "chunking_method": "ast",
    "content": "// Create a new process, copying the parent.\n// Sets up child kernel stack to return as if from fork() system call.\nint\nfork(void)\n{\n  int i, pid;\n  struct proc *np;\n  struct proc *p = myproc();\n\n  // Allocate process.\n  if((np = allocproc()) == 0){\n    return -1;\n  }\n\n  // Copy user memory from parent to child.\n  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){\n    freeproc(np);\n    release(&np->lock);\n    return -1;\n  }\n  np->sz = p->sz;\n\n  // copy saved user registers.\n  *(np->trapframe) = *(p->trapframe);\n\n  // Cause fork to return 0 in the child.\n  np->trapframe->a0 = 0;\n\n  // increment reference counts on open file descriptors.\n  for(i = 0; i < NOFILE; i++)\n    if(p->ofile[i])\n      np->ofile[i] = filedup(p->ofile[i]);\n  np->cwd = idup(p->cwd);\n\n  safestrcpy(np->name, p->name, sizeof(p->name));\n\n  pid = np->pid;\n\n  release(&np->lock);\n\n  acquire(&wait_lock);\n  np->parent = p;\n  release(&wait_lock);\n\n  acquire(&np->lock);\n  np->state = RUNNABLE;\n  release(&np->lock);\n\n  return pid;\n}",
    "chunk_function_names": [
      "growproc",
      "fork",
      "reparent"
    ],
    "document_function_names": [
      "proc_mapstacks",
      "procinit",
      "cpuid",
      "allocpid",
      "freeproc",
      "proc_pagetable",
      "code",
      "proc_freepagetable",
      "userinit",
      "growproc",
      "fork",
      "reparent",
      "wait",
      "wait",
      "scheduler",
      "sched",
      "yield",
      "scheduler",
      "sleep",
      "wakeup",
      "space",
      "setkilled",
      "killed",
      "either_copyout",
      "either_copyin",
      "procdump"
    ]
  }
]