[
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/main.c",
    "filename": "main.c",
    "relpath": "kernel/main.c",
    "start_line": 1,
    "end_line": 45,
    "length": 45,
    "content": "#include \"types.h\"\n#include \"param.h\"\n#include \"memlayout.h\"\n#include \"riscv.h\"\n#include \"defs.h\"\n\nvolatile static int started = 0;\n\n// start() jumps here in supervisor mode on all CPUs.\nvoid\nmain()\n{\n  if(cpuid() == 0){\n    consoleinit();\n    printfinit();\n    printf(\"\\n\");\n    printf(\"xv6 kernel is booting\\n\");\n    printf(\"\\n\");\n    kinit();         // physical page allocator\n    kvminit();       // create kernel page table\n    kvminithart();   // turn on paging\n    procinit();      // process table\n    trapinit();      // trap vectors\n    trapinithart();  // install kernel trap vector\n    plicinit();      // set up interrupt controller\n    plicinithart();  // ask PLIC for device interrupts\n    binit();         // buffer cache\n    iinit();         // inode table\n    fileinit();      // file table\n    virtio_disk_init(); // emulated hard disk\n    userinit();      // first user process\n    __sync_synchronize();\n    started = 1;\n  } else {\n    while(started == 0)\n      ;\n    __sync_synchronize();\n    printf(\"hart %d starting\\n\", cpuid());\n    kvminithart();    // turn on paging\n    trapinithart();   // install kernel trap vector\n    plicinithart();   // ask PLIC for device interrupts\n  }\n\n  scheduler();        \n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/user/usertests.c",
    "filename": "usertests.c",
    "relpath": "user/usertests.c",
    "start_line": 1,
    "end_line": 76,
    "length": 76,
    "content": "#include \"kernel/param.h\"\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/fs.h\"\n#include \"kernel/fcntl.h\"\n#include \"kernel/syscall.h\"\n#include \"kernel/memlayout.h\"\n#include \"kernel/riscv.h\"\n\n//\n// Tests xv6 system calls.  usertests without arguments runs them all\n// and usertests <name> runs <name> test. The test runner creates for\n// each test a process and based on the exit status of the process,\n// the test runner reports \"OK\" or \"FAILED\".  Some tests result in\n// kernel printing usertrap messages, which can be ignored if test\n// prints \"OK\".\n//\n\n#define BUFSZ  ((MAXOPBLOCKS+2)*BSIZE)\n\nchar buf[BUFSZ];\n\n//\n// Section with tests that run fairly quickly.  Use -q if you want to\n// run just those.  With -q usertests also runs the ones that take a\n// fair of time.\n//\n\n// what if you pass ridiculous pointers to system calls\n// that read user memory with copyin?\nvoid\ncopyin(char *s)\n{\n  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,\n                     0xffffffffffffffff };\n\n  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){\n    uint64 addr = addrs[ai];\n    \n    int fd = open(\"copyin1\", O_CREATE|O_WRONLY);\n    if(fd < 0){\n      printf(\"open(copyin1) failed\\n\");\n      exit(1);\n    }\n    int n = write(fd, (void*)addr, 8192);\n    if(n >= 0){\n      printf(\"write(fd, %p, 8192) returned %d, not -1\\n\", (void*)addr, n);\n      exit(1);\n    }\n    close(fd);\n    unlink(\"copyin1\");\n    \n    n = write(1, (char*)addr, 8192);\n    if(n > 0){\n      printf(\"write(1, %p, 8192) returned %d, not -1 or 0\\n\", (void*)addr, n);\n      exit(1);\n    }\n    \n    int fds[2];\n    if(pipe(fds) < 0){\n      printf(\"pipe() failed\\n\");\n      exit(1);\n    }\n    n = write(fds[1], (char*)addr, 8192);\n    if(n > 0){\n      printf(\"write(pipe, %p, 8192) returned %d, not -1 or 0\\n\", (void*)addr, n);\n      exit(1);\n    }\n    close(fds[0]);\n    close(fds[1]);\n  }\n}\n\n// what if you pass ridiculous pointers to system calls\n// that write user memory with copyout?"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/syscall.c",
    "filename": "syscall.c",
    "relpath": "kernel/syscall.c",
    "start_line": 92,
    "end_line": 147,
    "length": 56,
    "content": "extern uint64 sys_getpid(void);\nextern uint64 sys_sbrk(void);\nextern uint64 sys_sleep(void);\nextern uint64 sys_uptime(void);\nextern uint64 sys_open(void);\nextern uint64 sys_write(void);\nextern uint64 sys_mknod(void);\nextern uint64 sys_unlink(void);\nextern uint64 sys_link(void);\nextern uint64 sys_mkdir(void);\nextern uint64 sys_close(void);\n\n// An array mapping syscall numbers from syscall.h\n// to the function that handles the system call.\nstatic uint64 (*syscalls[])(void) = {\n[SYS_fork]    sys_fork,\n[SYS_exit]    sys_exit,\n[SYS_wait]    sys_wait,\n[SYS_pipe]    sys_pipe,\n[SYS_read]    sys_read,\n[SYS_kill]    sys_kill,\n[SYS_exec]    sys_exec,\n[SYS_fstat]   sys_fstat,\n[SYS_chdir]   sys_chdir,\n[SYS_dup]     sys_dup,\n[SYS_getpid]  sys_getpid,\n[SYS_sbrk]    sys_sbrk,\n[SYS_sleep]   sys_sleep,\n[SYS_uptime]  sys_uptime,\n[SYS_open]    sys_open,\n[SYS_write]   sys_write,\n[SYS_mknod]   sys_mknod,\n[SYS_unlink]  sys_unlink,\n[SYS_link]    sys_link,\n[SYS_mkdir]   sys_mkdir,\n[SYS_close]   sys_close,\n};\n\nvoid\nsyscall(void)\n{\n  int num;\n  struct proc *p = myproc();\n\n  num = p->trapframe->a7;\n  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {\n    // Use num to lookup the system call function for num, call it,\n    // and store its return value in p->trapframe->a0\n    p->trapframe->a0 = syscalls[num]();\n  } else {\n    printf(\"%d %s: unknown sys call %d\\n\",\n            p->pid, p->name, num);\n    p->trapframe->a0 = -1;\n  }\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/trap.c",
    "filename": "trap.c",
    "relpath": "kernel/trap.c",
    "start_line": 133,
    "end_line": 217,
    "length": 85,
    "content": "void \nkerneltrap()\n{\n  int which_dev = 0;\n  uint64 sepc = r_sepc();\n  uint64 sstatus = r_sstatus();\n  uint64 scause = r_scause();\n  \n  if((sstatus & SSTATUS_SPP) == 0)\n    panic(\"kerneltrap: not from supervisor mode\");\n  if(intr_get() != 0)\n    panic(\"kerneltrap: interrupts enabled\");\n\n  if((which_dev = devintr()) == 0){\n    // interrupt or trap from an unknown source\n    printf(\"scause=0x%lx sepc=0x%lx stval=0x%lx\\n\", scause, r_sepc(), r_stval());\n    panic(\"kerneltrap\");\n  }\n\n  // give up the CPU if this is a timer interrupt.\n  if(which_dev == 2 && myproc() != 0)\n    yield();\n\n  // the yield() may have caused some traps to occur,\n  // so restore trap registers for use by kernelvec.S's sepc instruction.\n  w_sepc(sepc);\n  w_sstatus(sstatus);\n}\n\nvoid\nclockintr()\n{\n  if(cpuid() == 0){\n    acquire(&tickslock);\n    ticks++;\n    wakeup(&ticks);\n    release(&tickslock);\n  }\n\n  // ask for the next timer interrupt. this also clears\n  // the interrupt request. 1000000 is about a tenth\n  // of a second.\n  w_stimecmp(r_time() + 1000000);\n}\n\n// check if it's an external interrupt or software interrupt,\n// and handle it.\n// returns 2 if timer interrupt,\n// 1 if other device,\n// 0 if not recognized.\nint\ndevintr()\n{\n  uint64 scause = r_scause();\n\n  if(scause == 0x8000000000000009L){\n    // this is a supervisor external interrupt, via PLIC.\n\n    // irq indicates which device interrupted.\n    int irq = plic_claim();\n\n    if(irq == UART0_IRQ){\n      uartintr();\n    } else if(irq == VIRTIO0_IRQ){\n      virtio_disk_intr();\n    } else if(irq){\n      printf(\"unexpected interrupt irq=%d\\n\", irq);\n    }\n\n    // the PLIC allows each device to raise at most one\n    // interrupt at a time; tell the PLIC the device is\n    // now allowed to interrupt again.\n    if(irq)\n      plic_complete(irq);\n\n    return 1;\n  } else if(scause == 0x8000000000000005L){\n    // timer interrupt.\n    clockintr();\n    return 2;\n  } else {\n    return 0;\n  }\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/syscall.c",
    "filename": "syscall.c",
    "relpath": "kernel/syscall.c",
    "start_line": 1,
    "end_line": 92,
    "length": 92,
    "content": "#include \"types.h\"\n#include \"param.h\"\n#include \"memlayout.h\"\n#include \"riscv.h\"\n#include \"spinlock.h\"\n#include \"proc.h\"\n#include \"syscall.h\"\n#include \"defs.h\"\n\n// Fetch the uint64 at addr from the current process.\nint\nfetchaddr(uint64 addr, uint64 *ip)\n{\n  struct proc *p = myproc();\n  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow\n    return -1;\n  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)\n    return -1;\n  return 0;\n}\n\n// Fetch the nul-terminated string at addr from the current process.\n// Returns length of string, not including nul, or -1 for error.\nint\nfetchstr(uint64 addr, char *buf, int max)\n{\n  struct proc *p = myproc();\n  if(copyinstr(p->pagetable, buf, addr, max) < 0)\n    return -1;\n  return strlen(buf);\n}\n\nstatic uint64\nargraw(int n)\n{\n  struct proc *p = myproc();\n  switch (n) {\n  case 0:\n    return p->trapframe->a0;\n  case 1:\n    return p->trapframe->a1;\n  case 2:\n    return p->trapframe->a2;\n  case 3:\n    return p->trapframe->a3;\n  case 4:\n    return p->trapframe->a4;\n  case 5:\n    return p->trapframe->a5;\n  }\n  panic(\"argraw\");\n  return -1;\n}\n\n// Fetch the nth 32-bit system call argument.\nvoid\nargint(int n, int *ip)\n{\n  *ip = argraw(n);\n}\n\n// Retrieve an argument as a pointer.\n// Doesn't check for legality, since\n// copyin/copyout will do that.\nvoid\nargaddr(int n, uint64 *ip)\n{\n  *ip = argraw(n);\n}\n\n// Fetch the nth word-sized system call argument as a null-terminated string.\n// Copies into buf, at most max.\n// Returns string length if OK (including nul), -1 if error.\nint\nargstr(int n, char *buf, int max)\n{\n  uint64 addr;\n  argaddr(n, &addr);\n  return fetchstr(addr, buf, max);\n}\n\n// Prototypes for the functions that handle system calls.\nextern uint64 sys_fork(void);\nextern uint64 sys_exit(void);\nextern uint64 sys_wait(void);\nextern uint64 sys_pipe(void);\nextern uint64 sys_read(void);\nextern uint64 sys_kill(void);\nextern uint64 sys_exec(void);\nextern uint64 sys_fstat(void);\nextern uint64 sys_chdir(void);\nextern uint64 sys_dup(void);"
  }
]
